"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/saxes@6.0.0";
exports.ids = ["vendor-chunks/saxes@6.0.0"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/saxes@6.0.0/node_modules/saxes/saxes.js":
/*!********************************************************************!*\
  !*** ./node_modules/.pnpm/saxes@6.0.0/node_modules/saxes/saxes.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SaxesParser = exports.EVENTS = void 0;\nconst ed5 = __webpack_require__(/*! xmlchars/xml/1.0/ed5 */ \"(ssr)/./node_modules/.pnpm/xmlchars@2.2.0/node_modules/xmlchars/xml/1.0/ed5.js\");\nconst ed2 = __webpack_require__(/*! xmlchars/xml/1.1/ed2 */ \"(ssr)/./node_modules/.pnpm/xmlchars@2.2.0/node_modules/xmlchars/xml/1.1/ed2.js\");\nconst NSed3 = __webpack_require__(/*! xmlchars/xmlns/1.0/ed3 */ \"(ssr)/./node_modules/.pnpm/xmlchars@2.2.0/node_modules/xmlchars/xmlns/1.0/ed3.js\");\nvar isS = ed5.isS;\nvar isChar10 = ed5.isChar;\nvar isNameStartChar = ed5.isNameStartChar;\nvar isNameChar = ed5.isNameChar;\nvar S_LIST = ed5.S_LIST;\nvar NAME_RE = ed5.NAME_RE;\nvar isChar11 = ed2.isChar;\nvar isNCNameStartChar = NSed3.isNCNameStartChar;\nvar isNCNameChar = NSed3.isNCNameChar;\nvar NC_NAME_RE = NSed3.NC_NAME_RE;\nconst XML_NAMESPACE = \"http://www.w3.org/XML/1998/namespace\";\nconst XMLNS_NAMESPACE = \"http://www.w3.org/2000/xmlns/\";\nconst rootNS = {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-assignment\n    __proto__: null,\n    xml: XML_NAMESPACE,\n    xmlns: XMLNS_NAMESPACE,\n};\nconst XML_ENTITIES = {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-assignment\n    __proto__: null,\n    amp: \"&\",\n    gt: \">\",\n    lt: \"<\",\n    quot: \"\\\"\",\n    apos: \"'\",\n};\n// EOC: end-of-chunk\nconst EOC = -1;\nconst NL_LIKE = -2;\nconst S_BEGIN = 0; // Initial state.\nconst S_BEGIN_WHITESPACE = 1; // leading whitespace\nconst S_DOCTYPE = 2; // <!DOCTYPE\nconst S_DOCTYPE_QUOTE = 3; // <!DOCTYPE \"//blah\nconst S_DTD = 4; // <!DOCTYPE \"//blah\" [ ...\nconst S_DTD_QUOTED = 5; // <!DOCTYPE \"//blah\" [ \"foo\nconst S_DTD_OPEN_WAKA = 6;\nconst S_DTD_OPEN_WAKA_BANG = 7;\nconst S_DTD_COMMENT = 8; // <!--\nconst S_DTD_COMMENT_ENDING = 9; // <!-- blah -\nconst S_DTD_COMMENT_ENDED = 10; // <!-- blah --\nconst S_DTD_PI = 11; // <?\nconst S_DTD_PI_ENDING = 12; // <?hi \"there\" ?\nconst S_TEXT = 13; // general stuff\nconst S_ENTITY = 14; // &amp and such\nconst S_OPEN_WAKA = 15; // <\nconst S_OPEN_WAKA_BANG = 16; // <!...\nconst S_COMMENT = 17; // <!--\nconst S_COMMENT_ENDING = 18; // <!-- blah -\nconst S_COMMENT_ENDED = 19; // <!-- blah --\nconst S_CDATA = 20; // <![CDATA[ something\nconst S_CDATA_ENDING = 21; // ]\nconst S_CDATA_ENDING_2 = 22; // ]]\nconst S_PI_FIRST_CHAR = 23; // <?hi, first char\nconst S_PI_REST = 24; // <?hi, rest of the name\nconst S_PI_BODY = 25; // <?hi there\nconst S_PI_ENDING = 26; // <?hi \"there\" ?\nconst S_XML_DECL_NAME_START = 27; // <?xml\nconst S_XML_DECL_NAME = 28; // <?xml foo\nconst S_XML_DECL_EQ = 29; // <?xml foo=\nconst S_XML_DECL_VALUE_START = 30; // <?xml foo=\nconst S_XML_DECL_VALUE = 31; // <?xml foo=\"bar\"\nconst S_XML_DECL_SEPARATOR = 32; // <?xml foo=\"bar\"\nconst S_XML_DECL_ENDING = 33; // <?xml ... ?\nconst S_OPEN_TAG = 34; // <strong\nconst S_OPEN_TAG_SLASH = 35; // <strong /\nconst S_ATTRIB = 36; // <a\nconst S_ATTRIB_NAME = 37; // <a foo\nconst S_ATTRIB_NAME_SAW_WHITE = 38; // <a foo _\nconst S_ATTRIB_VALUE = 39; // <a foo=\nconst S_ATTRIB_VALUE_QUOTED = 40; // <a foo=\"bar\nconst S_ATTRIB_VALUE_CLOSED = 41; // <a foo=\"bar\"\nconst S_ATTRIB_VALUE_UNQUOTED = 42; // <a foo=bar\nconst S_CLOSE_TAG = 43; // </a\nconst S_CLOSE_TAG_SAW_WHITE = 44; // </a   >\nconst TAB = 9;\nconst NL = 0xA;\nconst CR = 0xD;\nconst SPACE = 0x20;\nconst BANG = 0x21;\nconst DQUOTE = 0x22;\nconst AMP = 0x26;\nconst SQUOTE = 0x27;\nconst MINUS = 0x2D;\nconst FORWARD_SLASH = 0x2F;\nconst SEMICOLON = 0x3B;\nconst LESS = 0x3C;\nconst EQUAL = 0x3D;\nconst GREATER = 0x3E;\nconst QUESTION = 0x3F;\nconst OPEN_BRACKET = 0x5B;\nconst CLOSE_BRACKET = 0x5D;\nconst NEL = 0x85;\nconst LS = 0x2028; // Line Separator\nconst isQuote = (c) => c === DQUOTE || c === SQUOTE;\nconst QUOTES = [DQUOTE, SQUOTE];\nconst DOCTYPE_TERMINATOR = [...QUOTES, OPEN_BRACKET, GREATER];\nconst DTD_TERMINATOR = [...QUOTES, LESS, CLOSE_BRACKET];\nconst XML_DECL_NAME_TERMINATOR = [EQUAL, QUESTION, ...S_LIST];\nconst ATTRIB_VALUE_UNQUOTED_TERMINATOR = [...S_LIST, GREATER, AMP, LESS];\nfunction nsPairCheck(parser, prefix, uri) {\n    switch (prefix) {\n        case \"xml\":\n            if (uri !== XML_NAMESPACE) {\n                parser.fail(`xml prefix must be bound to ${XML_NAMESPACE}.`);\n            }\n            break;\n        case \"xmlns\":\n            if (uri !== XMLNS_NAMESPACE) {\n                parser.fail(`xmlns prefix must be bound to ${XMLNS_NAMESPACE}.`);\n            }\n            break;\n        default:\n    }\n    switch (uri) {\n        case XMLNS_NAMESPACE:\n            parser.fail(prefix === \"\" ?\n                `the default namespace may not be set to ${uri}.` :\n                `may not assign a prefix (even \"xmlns\") to the URI \\\n${XMLNS_NAMESPACE}.`);\n            break;\n        case XML_NAMESPACE:\n            switch (prefix) {\n                case \"xml\":\n                    // Assinging the XML namespace to \"xml\" is fine.\n                    break;\n                case \"\":\n                    parser.fail(`the default namespace may not be set to ${uri}.`);\n                    break;\n                default:\n                    parser.fail(\"may not assign the xml namespace to another prefix.\");\n            }\n            break;\n        default:\n    }\n}\nfunction nsMappingCheck(parser, mapping) {\n    for (const local of Object.keys(mapping)) {\n        nsPairCheck(parser, local, mapping[local]);\n    }\n}\nconst isNCName = (name) => NC_NAME_RE.test(name);\nconst isName = (name) => NAME_RE.test(name);\nconst FORBIDDEN_START = 0;\nconst FORBIDDEN_BRACKET = 1;\nconst FORBIDDEN_BRACKET_BRACKET = 2;\n/**\n * The list of supported events.\n */\nexports.EVENTS = [\n    \"xmldecl\",\n    \"text\",\n    \"processinginstruction\",\n    \"doctype\",\n    \"comment\",\n    \"opentagstart\",\n    \"attribute\",\n    \"opentag\",\n    \"closetag\",\n    \"cdata\",\n    \"error\",\n    \"end\",\n    \"ready\",\n];\nconst EVENT_NAME_TO_HANDLER_NAME = {\n    xmldecl: \"xmldeclHandler\",\n    text: \"textHandler\",\n    processinginstruction: \"piHandler\",\n    doctype: \"doctypeHandler\",\n    comment: \"commentHandler\",\n    opentagstart: \"openTagStartHandler\",\n    attribute: \"attributeHandler\",\n    opentag: \"openTagHandler\",\n    closetag: \"closeTagHandler\",\n    cdata: \"cdataHandler\",\n    error: \"errorHandler\",\n    end: \"endHandler\",\n    ready: \"readyHandler\",\n};\n// eslint-disable-next-line @typescript-eslint/ban-types\nclass SaxesParser {\n    /**\n     * @param opt The parser options.\n     */\n    constructor(opt) {\n        this.opt = opt !== null && opt !== void 0 ? opt : {};\n        this.fragmentOpt = !!this.opt.fragment;\n        const xmlnsOpt = this.xmlnsOpt = !!this.opt.xmlns;\n        this.trackPosition = this.opt.position !== false;\n        this.fileName = this.opt.fileName;\n        if (xmlnsOpt) {\n            // This is the function we use to perform name checks on PIs and entities.\n            // When namespaces are used, colons are not allowed in PI target names or\n            // entity names. So the check depends on whether namespaces are used. See:\n            //\n            // https://www.w3.org/XML/xml-names-19990114-errata.html\n            // NE08\n            //\n            this.nameStartCheck = isNCNameStartChar;\n            this.nameCheck = isNCNameChar;\n            this.isName = isNCName;\n            // eslint-disable-next-line @typescript-eslint/unbound-method\n            this.processAttribs = this.processAttribsNS;\n            // eslint-disable-next-line @typescript-eslint/unbound-method\n            this.pushAttrib = this.pushAttribNS;\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-assignment\n            this.ns = Object.assign({ __proto__: null }, rootNS);\n            const additional = this.opt.additionalNamespaces;\n            if (additional != null) {\n                nsMappingCheck(this, additional);\n                Object.assign(this.ns, additional);\n            }\n        }\n        else {\n            this.nameStartCheck = isNameStartChar;\n            this.nameCheck = isNameChar;\n            this.isName = isName;\n            // eslint-disable-next-line @typescript-eslint/unbound-method\n            this.processAttribs = this.processAttribsPlain;\n            // eslint-disable-next-line @typescript-eslint/unbound-method\n            this.pushAttrib = this.pushAttribPlain;\n        }\n        //\n        // The order of the members in this table needs to correspond to the state\n        // numbers given to the states that correspond to the methods being recorded\n        // here.\n        //\n        this.stateTable = [\n            /* eslint-disable @typescript-eslint/unbound-method */\n            this.sBegin,\n            this.sBeginWhitespace,\n            this.sDoctype,\n            this.sDoctypeQuote,\n            this.sDTD,\n            this.sDTDQuoted,\n            this.sDTDOpenWaka,\n            this.sDTDOpenWakaBang,\n            this.sDTDComment,\n            this.sDTDCommentEnding,\n            this.sDTDCommentEnded,\n            this.sDTDPI,\n            this.sDTDPIEnding,\n            this.sText,\n            this.sEntity,\n            this.sOpenWaka,\n            this.sOpenWakaBang,\n            this.sComment,\n            this.sCommentEnding,\n            this.sCommentEnded,\n            this.sCData,\n            this.sCDataEnding,\n            this.sCDataEnding2,\n            this.sPIFirstChar,\n            this.sPIRest,\n            this.sPIBody,\n            this.sPIEnding,\n            this.sXMLDeclNameStart,\n            this.sXMLDeclName,\n            this.sXMLDeclEq,\n            this.sXMLDeclValueStart,\n            this.sXMLDeclValue,\n            this.sXMLDeclSeparator,\n            this.sXMLDeclEnding,\n            this.sOpenTag,\n            this.sOpenTagSlash,\n            this.sAttrib,\n            this.sAttribName,\n            this.sAttribNameSawWhite,\n            this.sAttribValue,\n            this.sAttribValueQuoted,\n            this.sAttribValueClosed,\n            this.sAttribValueUnquoted,\n            this.sCloseTag,\n            this.sCloseTagSawWhite,\n            /* eslint-enable @typescript-eslint/unbound-method */\n        ];\n        this._init();\n    }\n    /**\n     * Indicates whether or not the parser is closed. If ``true``, wait for\n     * the ``ready`` event to write again.\n     */\n    get closed() {\n        return this._closed;\n    }\n    _init() {\n        var _a;\n        this.openWakaBang = \"\";\n        this.text = \"\";\n        this.name = \"\";\n        this.piTarget = \"\";\n        this.entity = \"\";\n        this.q = null;\n        this.tags = [];\n        this.tag = null;\n        this.topNS = null;\n        this.chunk = \"\";\n        this.chunkPosition = 0;\n        this.i = 0;\n        this.prevI = 0;\n        this.carriedFromPrevious = undefined;\n        this.forbiddenState = FORBIDDEN_START;\n        this.attribList = [];\n        // The logic is organized so as to minimize the need to check\n        // this.opt.fragment while parsing.\n        const { fragmentOpt } = this;\n        this.state = fragmentOpt ? S_TEXT : S_BEGIN;\n        // We want these to be all true if we are dealing with a fragment.\n        this.reportedTextBeforeRoot = this.reportedTextAfterRoot = this.closedRoot =\n            this.sawRoot = fragmentOpt;\n        // An XML declaration is intially possible only when parsing whole\n        // documents.\n        this.xmlDeclPossible = !fragmentOpt;\n        this.xmlDeclExpects = [\"version\"];\n        this.entityReturnState = undefined;\n        let { defaultXMLVersion } = this.opt;\n        if (defaultXMLVersion === undefined) {\n            if (this.opt.forceXMLVersion === true) {\n                throw new Error(\"forceXMLVersion set but defaultXMLVersion is not set\");\n            }\n            defaultXMLVersion = \"1.0\";\n        }\n        this.setXMLVersion(defaultXMLVersion);\n        this.positionAtNewLine = 0;\n        this.doctype = false;\n        this._closed = false;\n        this.xmlDecl = {\n            version: undefined,\n            encoding: undefined,\n            standalone: undefined,\n        };\n        this.line = 1;\n        this.column = 0;\n        this.ENTITIES = Object.create(XML_ENTITIES);\n        (_a = this.readyHandler) === null || _a === void 0 ? void 0 : _a.call(this);\n    }\n    /**\n     * The stream position the parser is currently looking at. This field is\n     * zero-based.\n     *\n     * This field is not based on counting Unicode characters but is to be\n     * interpreted as a plain index into a JavaScript string.\n     */\n    get position() {\n        return this.chunkPosition + this.i;\n    }\n    /**\n     * The column number of the next character to be read by the parser.  *\n     * This field is zero-based. (The first column in a line is 0.)\n     *\n     * This field reports the index at which the next character would be in the\n     * line if the line were represented as a JavaScript string.  Note that this\n     * *can* be different to a count based on the number of *Unicode characters*\n     * due to how JavaScript handles astral plane characters.\n     *\n     * See [[column]] for a number that corresponds to a count of Unicode\n     * characters.\n     */\n    get columnIndex() {\n        return this.position - this.positionAtNewLine;\n    }\n    /**\n     * Set an event listener on an event. The parser supports one handler per\n     * event type. If you try to set an event handler over an existing handler,\n     * the old handler is silently overwritten.\n     *\n     * @param name The event to listen to.\n     *\n     * @param handler The handler to set.\n     */\n    on(name, handler) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-member-access\n        this[EVENT_NAME_TO_HANDLER_NAME[name]] = handler;\n    }\n    /**\n     * Unset an event handler.\n     *\n     * @parma name The event to stop listening to.\n     */\n    off(name) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-member-access\n        this[EVENT_NAME_TO_HANDLER_NAME[name]] = undefined;\n    }\n    /**\n     * Make an error object. The error object will have a message that contains\n     * the ``fileName`` option passed at the creation of the parser. If position\n     * tracking was turned on, it will also have line and column number\n     * information.\n     *\n     * @param message The message describing the error to report.\n     *\n     * @returns An error object with a properly formatted message.\n     */\n    makeError(message) {\n        var _a;\n        let msg = (_a = this.fileName) !== null && _a !== void 0 ? _a : \"\";\n        if (this.trackPosition) {\n            if (msg.length > 0) {\n                msg += \":\";\n            }\n            msg += `${this.line}:${this.column}`;\n        }\n        if (msg.length > 0) {\n            msg += \": \";\n        }\n        return new Error(msg + message);\n    }\n    /**\n     * Report a parsing error. This method is made public so that client code may\n     * check for issues that are outside the scope of this project and can report\n     * errors.\n     *\n     * @param message The error to report.\n     *\n     * @returns this\n     */\n    fail(message) {\n        const err = this.makeError(message);\n        const handler = this.errorHandler;\n        if (handler === undefined) {\n            throw err;\n        }\n        else {\n            handler(err);\n        }\n        return this;\n    }\n    /**\n     * Write a XML data to the parser.\n     *\n     * @param chunk The XML data to write.\n     *\n     * @returns this\n     */\n    // We do need object for the type here. Yes, it often causes problems\n    // but not in this case.\n    write(chunk) {\n        if (this.closed) {\n            return this.fail(\"cannot write after close; assign an onready handler.\");\n        }\n        let end = false;\n        if (chunk === null) {\n            // We cannot return immediately because carriedFromPrevious may need\n            // processing.\n            end = true;\n            chunk = \"\";\n        }\n        else if (typeof chunk === \"object\") {\n            chunk = chunk.toString();\n        }\n        // We checked if performing a pre-decomposition of the string into an array\n        // of single complete characters (``Array.from(chunk)``) would be faster\n        // than the current repeated calls to ``charCodeAt``. As of August 2018, it\n        // isn't. (There may be Node-specific code that would perform faster than\n        // ``Array.from`` but don't want to be dependent on Node.)\n        if (this.carriedFromPrevious !== undefined) {\n            // The previous chunk had char we must carry over.\n            chunk = `${this.carriedFromPrevious}${chunk}`;\n            this.carriedFromPrevious = undefined;\n        }\n        let limit = chunk.length;\n        const lastCode = chunk.charCodeAt(limit - 1);\n        if (!end &&\n            // A trailing CR or surrogate must be carried over to the next\n            // chunk.\n            (lastCode === CR || (lastCode >= 0xD800 && lastCode <= 0xDBFF))) {\n            // The chunk ends with a character that must be carried over. We cannot\n            // know how to handle it until we get the next chunk or the end of the\n            // stream. So save it for later.\n            this.carriedFromPrevious = chunk[limit - 1];\n            limit--;\n            chunk = chunk.slice(0, limit);\n        }\n        const { stateTable } = this;\n        this.chunk = chunk;\n        this.i = 0;\n        while (this.i < limit) {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-argument\n            stateTable[this.state].call(this);\n        }\n        this.chunkPosition += limit;\n        return end ? this.end() : this;\n    }\n    /**\n     * Close the current stream. Perform final well-formedness checks and reset\n     * the parser tstate.\n     *\n     * @returns this\n     */\n    close() {\n        return this.write(null);\n    }\n    /**\n     * Get a single code point out of the current chunk. This updates the current\n     * position if we do position tracking.\n     *\n     * This is the algorithm to use for XML 1.0.\n     *\n     * @returns The character read.\n     */\n    getCode10() {\n        const { chunk, i } = this;\n        this.prevI = i;\n        // Yes, we do this instead of doing this.i++. Doing it this way, we do not\n        // read this.i again, which is a bit faster.\n        this.i = i + 1;\n        if (i >= chunk.length) {\n            return EOC;\n        }\n        // Using charCodeAt and handling the surrogates ourselves is faster\n        // than using codePointAt.\n        const code = chunk.charCodeAt(i);\n        this.column++;\n        if (code < 0xD800) {\n            if (code >= SPACE || code === TAB) {\n                return code;\n            }\n            switch (code) {\n                case NL:\n                    this.line++;\n                    this.column = 0;\n                    this.positionAtNewLine = this.position;\n                    return NL;\n                case CR:\n                    // We may get NaN if we read past the end of the chunk, which is fine.\n                    if (chunk.charCodeAt(i + 1) === NL) {\n                        // A \\r\\n sequence is converted to \\n so we have to skip over the\n                        // next character. We already know it has a size of 1 so ++ is fine\n                        // here.\n                        this.i = i + 2;\n                    }\n                    // Otherwise, a \\r is just converted to \\n, so we don't have to skip\n                    // ahead.\n                    // In either case, \\r becomes \\n.\n                    this.line++;\n                    this.column = 0;\n                    this.positionAtNewLine = this.position;\n                    return NL_LIKE;\n                default:\n                    // If we get here, then code < SPACE and it is not NL CR or TAB.\n                    this.fail(\"disallowed character.\");\n                    return code;\n            }\n        }\n        if (code > 0xDBFF) {\n            // This is a specialized version of isChar10 that takes into account\n            // that in this context code > 0xDBFF and code <= 0xFFFF. So it does not\n            // test cases that don't need testing.\n            if (!(code >= 0xE000 && code <= 0xFFFD)) {\n                this.fail(\"disallowed character.\");\n            }\n            return code;\n        }\n        const final = 0x10000 + ((code - 0xD800) * 0x400) +\n            (chunk.charCodeAt(i + 1) - 0xDC00);\n        this.i = i + 2;\n        // This is a specialized version of isChar10 that takes into account that in\n        // this context necessarily final >= 0x10000.\n        if (final > 0x10FFFF) {\n            this.fail(\"disallowed character.\");\n        }\n        return final;\n    }\n    /**\n     * Get a single code point out of the current chunk. This updates the current\n     * position if we do position tracking.\n     *\n     * This is the algorithm to use for XML 1.1.\n     *\n     * @returns {number} The character read.\n     */\n    getCode11() {\n        const { chunk, i } = this;\n        this.prevI = i;\n        // Yes, we do this instead of doing this.i++. Doing it this way, we do not\n        // read this.i again, which is a bit faster.\n        this.i = i + 1;\n        if (i >= chunk.length) {\n            return EOC;\n        }\n        // Using charCodeAt and handling the surrogates ourselves is faster\n        // than using codePointAt.\n        const code = chunk.charCodeAt(i);\n        this.column++;\n        if (code < 0xD800) {\n            if ((code > 0x1F && code < 0x7F) || (code > 0x9F && code !== LS) ||\n                code === TAB) {\n                return code;\n            }\n            switch (code) {\n                case NL: // 0xA\n                    this.line++;\n                    this.column = 0;\n                    this.positionAtNewLine = this.position;\n                    return NL;\n                case CR: { // 0xD\n                    // We may get NaN if we read past the end of the chunk, which is\n                    // fine.\n                    const next = chunk.charCodeAt(i + 1);\n                    if (next === NL || next === NEL) {\n                        // A CR NL or CR NEL sequence is converted to NL so we have to skip\n                        // over the next character. We already know it has a size of 1.\n                        this.i = i + 2;\n                    }\n                    // Otherwise, a CR is just converted to NL, no skip.\n                }\n                /* yes, fall through */\n                case NEL: // 0x85\n                case LS: // Ox2028\n                    this.line++;\n                    this.column = 0;\n                    this.positionAtNewLine = this.position;\n                    return NL_LIKE;\n                default:\n                    this.fail(\"disallowed character.\");\n                    return code;\n            }\n        }\n        if (code > 0xDBFF) {\n            // This is a specialized version of isCharAndNotRestricted that takes into\n            // account that in this context code > 0xDBFF and code <= 0xFFFF. So it\n            // does not test cases that don't need testing.\n            if (!(code >= 0xE000 && code <= 0xFFFD)) {\n                this.fail(\"disallowed character.\");\n            }\n            return code;\n        }\n        const final = 0x10000 + ((code - 0xD800) * 0x400) +\n            (chunk.charCodeAt(i + 1) - 0xDC00);\n        this.i = i + 2;\n        // This is a specialized version of isCharAndNotRestricted that takes into\n        // account that in this context necessarily final >= 0x10000.\n        if (final > 0x10FFFF) {\n            this.fail(\"disallowed character.\");\n        }\n        return final;\n    }\n    /**\n     * Like ``getCode`` but with the return value normalized so that ``NL`` is\n     * returned for ``NL_LIKE``.\n     */\n    getCodeNorm() {\n        const c = this.getCode();\n        return c === NL_LIKE ? NL : c;\n    }\n    unget() {\n        this.i = this.prevI;\n        this.column--;\n    }\n    /**\n     * Capture characters into a buffer until encountering one of a set of\n     * characters.\n     *\n     * @param chars An array of codepoints. Encountering a character in the array\n     * ends the capture. (``chars`` may safely contain ``NL``.)\n     *\n     * @return The character code that made the capture end, or ``EOC`` if we hit\n     * the end of the chunk. The return value cannot be NL_LIKE: NL is returned\n     * instead.\n     */\n    captureTo(chars) {\n        let { i: start } = this;\n        const { chunk } = this;\n        // eslint-disable-next-line no-constant-condition\n        while (true) {\n            const c = this.getCode();\n            const isNLLike = c === NL_LIKE;\n            const final = isNLLike ? NL : c;\n            if (final === EOC || chars.includes(final)) {\n                this.text += chunk.slice(start, this.prevI);\n                return final;\n            }\n            if (isNLLike) {\n                this.text += `${chunk.slice(start, this.prevI)}\\n`;\n                start = this.i;\n            }\n        }\n    }\n    /**\n     * Capture characters into a buffer until encountering a character.\n     *\n     * @param char The codepoint that ends the capture. **NOTE ``char`` MAY NOT\n     * CONTAIN ``NL``.** Passing ``NL`` will result in buggy behavior.\n     *\n     * @return ``true`` if we ran into the character. Otherwise, we ran into the\n     * end of the current chunk.\n     */\n    captureToChar(char) {\n        let { i: start } = this;\n        const { chunk } = this;\n        // eslint-disable-next-line no-constant-condition\n        while (true) {\n            let c = this.getCode();\n            switch (c) {\n                case NL_LIKE:\n                    this.text += `${chunk.slice(start, this.prevI)}\\n`;\n                    start = this.i;\n                    c = NL;\n                    break;\n                case EOC:\n                    this.text += chunk.slice(start);\n                    return false;\n                default:\n            }\n            if (c === char) {\n                this.text += chunk.slice(start, this.prevI);\n                return true;\n            }\n        }\n    }\n    /**\n     * Capture characters that satisfy ``isNameChar`` into the ``name`` field of\n     * this parser.\n     *\n     * @return The character code that made the test fail, or ``EOC`` if we hit\n     * the end of the chunk. The return value cannot be NL_LIKE: NL is returned\n     * instead.\n     */\n    captureNameChars() {\n        const { chunk, i: start } = this;\n        // eslint-disable-next-line no-constant-condition\n        while (true) {\n            const c = this.getCode();\n            if (c === EOC) {\n                this.name += chunk.slice(start);\n                return EOC;\n            }\n            // NL is not a name char so we don't have to test specifically for it.\n            if (!isNameChar(c)) {\n                this.name += chunk.slice(start, this.prevI);\n                return c === NL_LIKE ? NL : c;\n            }\n        }\n    }\n    /**\n     * Skip white spaces.\n     *\n     * @return The character that ended the skip, or ``EOC`` if we hit\n     * the end of the chunk. The return value cannot be NL_LIKE: NL is returned\n     * instead.\n     */\n    skipSpaces() {\n        // eslint-disable-next-line no-constant-condition\n        while (true) {\n            const c = this.getCodeNorm();\n            if (c === EOC || !isS(c)) {\n                return c;\n            }\n        }\n    }\n    setXMLVersion(version) {\n        this.currentXMLVersion = version;\n        /*  eslint-disable @typescript-eslint/unbound-method */\n        if (version === \"1.0\") {\n            this.isChar = isChar10;\n            this.getCode = this.getCode10;\n        }\n        else {\n            this.isChar = isChar11;\n            this.getCode = this.getCode11;\n        }\n        /* eslint-enable @typescript-eslint/unbound-method */\n    }\n    // STATE ENGINE METHODS\n    // This needs to be a state separate from S_BEGIN_WHITESPACE because we want\n    // to be sure never to come back to this state later.\n    sBegin() {\n        // We are essentially peeking at the first character of the chunk. Since\n        // S_BEGIN can be in effect only when we start working on the first chunk,\n        // the index at which we must look is necessarily 0. Note also that the\n        // following test does not depend on decoding surrogates.\n        // If the initial character is 0xFEFF, ignore it.\n        if (this.chunk.charCodeAt(0) === 0xFEFF) {\n            this.i++;\n            this.column++;\n        }\n        this.state = S_BEGIN_WHITESPACE;\n    }\n    sBeginWhitespace() {\n        // We need to know whether we've encountered spaces or not because as soon\n        // as we run into a space, an XML declaration is no longer possible. Rather\n        // than slow down skipSpaces even in places where we don't care whether it\n        // skipped anything or not, we check whether prevI is equal to the value of\n        // i from before we skip spaces.\n        const iBefore = this.i;\n        const c = this.skipSpaces();\n        if (this.prevI !== iBefore) {\n            this.xmlDeclPossible = false;\n        }\n        switch (c) {\n            case LESS:\n                this.state = S_OPEN_WAKA;\n                // We could naively call closeText but in this state, it is not normal\n                // to have text be filled with any data.\n                if (this.text.length !== 0) {\n                    throw new Error(\"no-empty text at start\");\n                }\n                break;\n            case EOC:\n                break;\n            default:\n                this.unget();\n                this.state = S_TEXT;\n                this.xmlDeclPossible = false;\n        }\n    }\n    sDoctype() {\n        var _a;\n        const c = this.captureTo(DOCTYPE_TERMINATOR);\n        switch (c) {\n            case GREATER: {\n                (_a = this.doctypeHandler) === null || _a === void 0 ? void 0 : _a.call(this, this.text);\n                this.text = \"\";\n                this.state = S_TEXT;\n                this.doctype = true; // just remember that we saw it.\n                break;\n            }\n            case EOC:\n                break;\n            default:\n                this.text += String.fromCodePoint(c);\n                if (c === OPEN_BRACKET) {\n                    this.state = S_DTD;\n                }\n                else if (isQuote(c)) {\n                    this.state = S_DOCTYPE_QUOTE;\n                    this.q = c;\n                }\n        }\n    }\n    sDoctypeQuote() {\n        const q = this.q;\n        if (this.captureToChar(q)) {\n            this.text += String.fromCodePoint(q);\n            this.q = null;\n            this.state = S_DOCTYPE;\n        }\n    }\n    sDTD() {\n        const c = this.captureTo(DTD_TERMINATOR);\n        if (c === EOC) {\n            return;\n        }\n        this.text += String.fromCodePoint(c);\n        if (c === CLOSE_BRACKET) {\n            this.state = S_DOCTYPE;\n        }\n        else if (c === LESS) {\n            this.state = S_DTD_OPEN_WAKA;\n        }\n        else if (isQuote(c)) {\n            this.state = S_DTD_QUOTED;\n            this.q = c;\n        }\n    }\n    sDTDQuoted() {\n        const q = this.q;\n        if (this.captureToChar(q)) {\n            this.text += String.fromCodePoint(q);\n            this.state = S_DTD;\n            this.q = null;\n        }\n    }\n    sDTDOpenWaka() {\n        const c = this.getCodeNorm();\n        this.text += String.fromCodePoint(c);\n        switch (c) {\n            case BANG:\n                this.state = S_DTD_OPEN_WAKA_BANG;\n                this.openWakaBang = \"\";\n                break;\n            case QUESTION:\n                this.state = S_DTD_PI;\n                break;\n            default:\n                this.state = S_DTD;\n        }\n    }\n    sDTDOpenWakaBang() {\n        const char = String.fromCodePoint(this.getCodeNorm());\n        const owb = this.openWakaBang += char;\n        this.text += char;\n        if (owb !== \"-\") {\n            this.state = owb === \"--\" ? S_DTD_COMMENT : S_DTD;\n            this.openWakaBang = \"\";\n        }\n    }\n    sDTDComment() {\n        if (this.captureToChar(MINUS)) {\n            this.text += \"-\";\n            this.state = S_DTD_COMMENT_ENDING;\n        }\n    }\n    sDTDCommentEnding() {\n        const c = this.getCodeNorm();\n        this.text += String.fromCodePoint(c);\n        this.state = c === MINUS ? S_DTD_COMMENT_ENDED : S_DTD_COMMENT;\n    }\n    sDTDCommentEnded() {\n        const c = this.getCodeNorm();\n        this.text += String.fromCodePoint(c);\n        if (c === GREATER) {\n            this.state = S_DTD;\n        }\n        else {\n            this.fail(\"malformed comment.\");\n            // <!-- blah -- bloo --> will be recorded as\n            // a comment of \" blah -- bloo \"\n            this.state = S_DTD_COMMENT;\n        }\n    }\n    sDTDPI() {\n        if (this.captureToChar(QUESTION)) {\n            this.text += \"?\";\n            this.state = S_DTD_PI_ENDING;\n        }\n    }\n    sDTDPIEnding() {\n        const c = this.getCodeNorm();\n        this.text += String.fromCodePoint(c);\n        if (c === GREATER) {\n            this.state = S_DTD;\n        }\n    }\n    sText() {\n        //\n        // We did try a version of saxes where the S_TEXT state was split in two\n        // states: one for text inside the root element, and one for text\n        // outside. This was avoiding having to test this.tags.length to decide\n        // what implementation to actually use.\n        //\n        // Peformance testing on gigabyte-size files did not show any advantage to\n        // using the two states solution instead of the current one. Conversely, it\n        // made the code a bit more complicated elsewhere. For instance, a comment\n        // can appear before the root element so when a comment ended it was\n        // necessary to determine whether to return to the S_TEXT state or to the\n        // new text-outside-root state.\n        //\n        if (this.tags.length !== 0) {\n            this.handleTextInRoot();\n        }\n        else {\n            this.handleTextOutsideRoot();\n        }\n    }\n    sEntity() {\n        // This is essentially a specialized version of captureToChar(SEMICOLON...)\n        let { i: start } = this;\n        const { chunk } = this;\n        // eslint-disable-next-line no-labels, no-restricted-syntax\n        loop: \n        // eslint-disable-next-line no-constant-condition\n        while (true) {\n            switch (this.getCode()) {\n                case NL_LIKE:\n                    this.entity += `${chunk.slice(start, this.prevI)}\\n`;\n                    start = this.i;\n                    break;\n                case SEMICOLON: {\n                    const { entityReturnState } = this;\n                    const entity = this.entity + chunk.slice(start, this.prevI);\n                    this.state = entityReturnState;\n                    let parsed;\n                    if (entity === \"\") {\n                        this.fail(\"empty entity name.\");\n                        parsed = \"&;\";\n                    }\n                    else {\n                        parsed = this.parseEntity(entity);\n                        this.entity = \"\";\n                    }\n                    if (entityReturnState !== S_TEXT || this.textHandler !== undefined) {\n                        this.text += parsed;\n                    }\n                    // eslint-disable-next-line no-labels\n                    break loop;\n                }\n                case EOC:\n                    this.entity += chunk.slice(start);\n                    // eslint-disable-next-line no-labels\n                    break loop;\n                default:\n            }\n        }\n    }\n    sOpenWaka() {\n        // Reminder: a state handler is called with at least one character\n        // available in the current chunk. So the first call to get code inside of\n        // a state handler cannot return ``EOC``. That's why we don't test\n        // for it.\n        const c = this.getCode();\n        // either a /, ?, !, or text is coming next.\n        if (isNameStartChar(c)) {\n            this.state = S_OPEN_TAG;\n            this.unget();\n            this.xmlDeclPossible = false;\n        }\n        else {\n            switch (c) {\n                case FORWARD_SLASH:\n                    this.state = S_CLOSE_TAG;\n                    this.xmlDeclPossible = false;\n                    break;\n                case BANG:\n                    this.state = S_OPEN_WAKA_BANG;\n                    this.openWakaBang = \"\";\n                    this.xmlDeclPossible = false;\n                    break;\n                case QUESTION:\n                    this.state = S_PI_FIRST_CHAR;\n                    break;\n                default:\n                    this.fail(\"disallowed character in tag name\");\n                    this.state = S_TEXT;\n                    this.xmlDeclPossible = false;\n            }\n        }\n    }\n    sOpenWakaBang() {\n        this.openWakaBang += String.fromCodePoint(this.getCodeNorm());\n        switch (this.openWakaBang) {\n            case \"[CDATA[\":\n                if (!this.sawRoot && !this.reportedTextBeforeRoot) {\n                    this.fail(\"text data outside of root node.\");\n                    this.reportedTextBeforeRoot = true;\n                }\n                if (this.closedRoot && !this.reportedTextAfterRoot) {\n                    this.fail(\"text data outside of root node.\");\n                    this.reportedTextAfterRoot = true;\n                }\n                this.state = S_CDATA;\n                this.openWakaBang = \"\";\n                break;\n            case \"--\":\n                this.state = S_COMMENT;\n                this.openWakaBang = \"\";\n                break;\n            case \"DOCTYPE\":\n                this.state = S_DOCTYPE;\n                if (this.doctype || this.sawRoot) {\n                    this.fail(\"inappropriately located doctype declaration.\");\n                }\n                this.openWakaBang = \"\";\n                break;\n            default:\n                // 7 happens to be the maximum length of the string that can possibly\n                // match one of the cases above.\n                if (this.openWakaBang.length >= 7) {\n                    this.fail(\"incorrect syntax.\");\n                }\n        }\n    }\n    sComment() {\n        if (this.captureToChar(MINUS)) {\n            this.state = S_COMMENT_ENDING;\n        }\n    }\n    sCommentEnding() {\n        var _a;\n        const c = this.getCodeNorm();\n        if (c === MINUS) {\n            this.state = S_COMMENT_ENDED;\n            (_a = this.commentHandler) === null || _a === void 0 ? void 0 : _a.call(this, this.text);\n            this.text = \"\";\n        }\n        else {\n            this.text += `-${String.fromCodePoint(c)}`;\n            this.state = S_COMMENT;\n        }\n    }\n    sCommentEnded() {\n        const c = this.getCodeNorm();\n        if (c !== GREATER) {\n            this.fail(\"malformed comment.\");\n            // <!-- blah -- bloo --> will be recorded as\n            // a comment of \" blah -- bloo \"\n            this.text += `--${String.fromCodePoint(c)}`;\n            this.state = S_COMMENT;\n        }\n        else {\n            this.state = S_TEXT;\n        }\n    }\n    sCData() {\n        if (this.captureToChar(CLOSE_BRACKET)) {\n            this.state = S_CDATA_ENDING;\n        }\n    }\n    sCDataEnding() {\n        const c = this.getCodeNorm();\n        if (c === CLOSE_BRACKET) {\n            this.state = S_CDATA_ENDING_2;\n        }\n        else {\n            this.text += `]${String.fromCodePoint(c)}`;\n            this.state = S_CDATA;\n        }\n    }\n    sCDataEnding2() {\n        var _a;\n        const c = this.getCodeNorm();\n        switch (c) {\n            case GREATER: {\n                (_a = this.cdataHandler) === null || _a === void 0 ? void 0 : _a.call(this, this.text);\n                this.text = \"\";\n                this.state = S_TEXT;\n                break;\n            }\n            case CLOSE_BRACKET:\n                this.text += \"]\";\n                break;\n            default:\n                this.text += `]]${String.fromCodePoint(c)}`;\n                this.state = S_CDATA;\n        }\n    }\n    // We need this separate state to check the first character fo the pi target\n    // with this.nameStartCheck which allows less characters than this.nameCheck.\n    sPIFirstChar() {\n        const c = this.getCodeNorm();\n        // This is first because in the case where the file is well-formed this is\n        // the branch taken. We optimize for well-formedness.\n        if (this.nameStartCheck(c)) {\n            this.piTarget += String.fromCodePoint(c);\n            this.state = S_PI_REST;\n        }\n        else if (c === QUESTION || isS(c)) {\n            this.fail(\"processing instruction without a target.\");\n            this.state = c === QUESTION ? S_PI_ENDING : S_PI_BODY;\n        }\n        else {\n            this.fail(\"disallowed character in processing instruction name.\");\n            this.piTarget += String.fromCodePoint(c);\n            this.state = S_PI_REST;\n        }\n    }\n    sPIRest() {\n        // Capture characters into a piTarget while ``this.nameCheck`` run on the\n        // character read returns true.\n        const { chunk, i: start } = this;\n        // eslint-disable-next-line no-constant-condition\n        while (true) {\n            const c = this.getCodeNorm();\n            if (c === EOC) {\n                this.piTarget += chunk.slice(start);\n                return;\n            }\n            // NL cannot satisfy this.nameCheck so we don't have to test specifically\n            // for it.\n            if (!this.nameCheck(c)) {\n                this.piTarget += chunk.slice(start, this.prevI);\n                const isQuestion = c === QUESTION;\n                if (isQuestion || isS(c)) {\n                    if (this.piTarget === \"xml\") {\n                        if (!this.xmlDeclPossible) {\n                            this.fail(\"an XML declaration must be at the start of the document.\");\n                        }\n                        this.state = isQuestion ? S_XML_DECL_ENDING : S_XML_DECL_NAME_START;\n                    }\n                    else {\n                        this.state = isQuestion ? S_PI_ENDING : S_PI_BODY;\n                    }\n                }\n                else {\n                    this.fail(\"disallowed character in processing instruction name.\");\n                    this.piTarget += String.fromCodePoint(c);\n                }\n                break;\n            }\n        }\n    }\n    sPIBody() {\n        if (this.text.length === 0) {\n            const c = this.getCodeNorm();\n            if (c === QUESTION) {\n                this.state = S_PI_ENDING;\n            }\n            else if (!isS(c)) {\n                this.text = String.fromCodePoint(c);\n            }\n        }\n        // The question mark character is not valid inside any of the XML\n        // declaration name/value pairs.\n        else if (this.captureToChar(QUESTION)) {\n            this.state = S_PI_ENDING;\n        }\n    }\n    sPIEnding() {\n        var _a;\n        const c = this.getCodeNorm();\n        if (c === GREATER) {\n            const { piTarget } = this;\n            if (piTarget.toLowerCase() === \"xml\") {\n                this.fail(\"the XML declaration must appear at the start of the document.\");\n            }\n            (_a = this.piHandler) === null || _a === void 0 ? void 0 : _a.call(this, {\n                target: piTarget,\n                body: this.text,\n            });\n            this.piTarget = this.text = \"\";\n            this.state = S_TEXT;\n        }\n        else if (c === QUESTION) {\n            // We ran into ?? as part of a processing instruction. We initially took\n            // the first ? as a sign that the PI was ending, but it is not. So we have\n            // to add it to the body but we take the new ? as a sign that the PI is\n            // ending.\n            this.text += \"?\";\n        }\n        else {\n            this.text += `?${String.fromCodePoint(c)}`;\n            this.state = S_PI_BODY;\n        }\n        this.xmlDeclPossible = false;\n    }\n    sXMLDeclNameStart() {\n        const c = this.skipSpaces();\n        // The question mark character is not valid inside any of the XML\n        // declaration name/value pairs.\n        if (c === QUESTION) {\n            // It is valid to go to S_XML_DECL_ENDING from this state.\n            this.state = S_XML_DECL_ENDING;\n            return;\n        }\n        if (c !== EOC) {\n            this.state = S_XML_DECL_NAME;\n            this.name = String.fromCodePoint(c);\n        }\n    }\n    sXMLDeclName() {\n        const c = this.captureTo(XML_DECL_NAME_TERMINATOR);\n        // The question mark character is not valid inside any of the XML\n        // declaration name/value pairs.\n        if (c === QUESTION) {\n            this.state = S_XML_DECL_ENDING;\n            this.name += this.text;\n            this.text = \"\";\n            this.fail(\"XML declaration is incomplete.\");\n            return;\n        }\n        if (!(isS(c) || c === EQUAL)) {\n            return;\n        }\n        this.name += this.text;\n        this.text = \"\";\n        if (!this.xmlDeclExpects.includes(this.name)) {\n            switch (this.name.length) {\n                case 0:\n                    this.fail(\"did not expect any more name/value pairs.\");\n                    break;\n                case 1:\n                    this.fail(`expected the name ${this.xmlDeclExpects[0]}.`);\n                    break;\n                default:\n                    this.fail(`expected one of ${this.xmlDeclExpects.join(\", \")}`);\n            }\n        }\n        this.state = c === EQUAL ? S_XML_DECL_VALUE_START : S_XML_DECL_EQ;\n    }\n    sXMLDeclEq() {\n        const c = this.getCodeNorm();\n        // The question mark character is not valid inside any of the XML\n        // declaration name/value pairs.\n        if (c === QUESTION) {\n            this.state = S_XML_DECL_ENDING;\n            this.fail(\"XML declaration is incomplete.\");\n            return;\n        }\n        if (isS(c)) {\n            return;\n        }\n        if (c !== EQUAL) {\n            this.fail(\"value required.\");\n        }\n        this.state = S_XML_DECL_VALUE_START;\n    }\n    sXMLDeclValueStart() {\n        const c = this.getCodeNorm();\n        // The question mark character is not valid inside any of the XML\n        // declaration name/value pairs.\n        if (c === QUESTION) {\n            this.state = S_XML_DECL_ENDING;\n            this.fail(\"XML declaration is incomplete.\");\n            return;\n        }\n        if (isS(c)) {\n            return;\n        }\n        if (!isQuote(c)) {\n            this.fail(\"value must be quoted.\");\n            this.q = SPACE;\n        }\n        else {\n            this.q = c;\n        }\n        this.state = S_XML_DECL_VALUE;\n    }\n    sXMLDeclValue() {\n        const c = this.captureTo([this.q, QUESTION]);\n        // The question mark character is not valid inside any of the XML\n        // declaration name/value pairs.\n        if (c === QUESTION) {\n            this.state = S_XML_DECL_ENDING;\n            this.text = \"\";\n            this.fail(\"XML declaration is incomplete.\");\n            return;\n        }\n        if (c === EOC) {\n            return;\n        }\n        const value = this.text;\n        this.text = \"\";\n        switch (this.name) {\n            case \"version\": {\n                this.xmlDeclExpects = [\"encoding\", \"standalone\"];\n                const version = value;\n                this.xmlDecl.version = version;\n                // This is the test specified by XML 1.0 but it is fine for XML 1.1.\n                if (!/^1\\.[0-9]+$/.test(version)) {\n                    this.fail(\"version number must match /^1\\\\.[0-9]+$/.\");\n                }\n                // When forceXMLVersion is set, the XML declaration is ignored.\n                else if (!this.opt.forceXMLVersion) {\n                    this.setXMLVersion(version);\n                }\n                break;\n            }\n            case \"encoding\":\n                if (!/^[A-Za-z][A-Za-z0-9._-]*$/.test(value)) {\n                    this.fail(\"encoding value must match \\\n/^[A-Za-z0-9][A-Za-z0-9._-]*$/.\");\n                }\n                this.xmlDeclExpects = [\"standalone\"];\n                this.xmlDecl.encoding = value;\n                break;\n            case \"standalone\":\n                if (value !== \"yes\" && value !== \"no\") {\n                    this.fail(\"standalone value must match \\\"yes\\\" or \\\"no\\\".\");\n                }\n                this.xmlDeclExpects = [];\n                this.xmlDecl.standalone = value;\n                break;\n            default:\n            // We don't need to raise an error here since we've already raised one\n            // when checking what name was expected.\n        }\n        this.name = \"\";\n        this.state = S_XML_DECL_SEPARATOR;\n    }\n    sXMLDeclSeparator() {\n        const c = this.getCodeNorm();\n        // The question mark character is not valid inside any of the XML\n        // declaration name/value pairs.\n        if (c === QUESTION) {\n            // It is valid to go to S_XML_DECL_ENDING from this state.\n            this.state = S_XML_DECL_ENDING;\n            return;\n        }\n        if (!isS(c)) {\n            this.fail(\"whitespace required.\");\n            this.unget();\n        }\n        this.state = S_XML_DECL_NAME_START;\n    }\n    sXMLDeclEnding() {\n        var _a;\n        const c = this.getCodeNorm();\n        if (c === GREATER) {\n            if (this.piTarget !== \"xml\") {\n                this.fail(\"processing instructions are not allowed before root.\");\n            }\n            else if (this.name !== \"version\" &&\n                this.xmlDeclExpects.includes(\"version\")) {\n                this.fail(\"XML declaration must contain a version.\");\n            }\n            (_a = this.xmldeclHandler) === null || _a === void 0 ? void 0 : _a.call(this, this.xmlDecl);\n            this.name = \"\";\n            this.piTarget = this.text = \"\";\n            this.state = S_TEXT;\n        }\n        else {\n            // We got here because the previous character was a ?, but the question\n            // mark character is not valid inside any of the XML declaration\n            // name/value pairs.\n            this.fail(\"The character ? is disallowed anywhere in XML declarations.\");\n        }\n        this.xmlDeclPossible = false;\n    }\n    sOpenTag() {\n        var _a;\n        const c = this.captureNameChars();\n        if (c === EOC) {\n            return;\n        }\n        const tag = this.tag = {\n            name: this.name,\n            attributes: Object.create(null),\n        };\n        this.name = \"\";\n        if (this.xmlnsOpt) {\n            this.topNS = tag.ns = Object.create(null);\n        }\n        (_a = this.openTagStartHandler) === null || _a === void 0 ? void 0 : _a.call(this, tag);\n        this.sawRoot = true;\n        if (!this.fragmentOpt && this.closedRoot) {\n            this.fail(\"documents may contain only one root.\");\n        }\n        switch (c) {\n            case GREATER:\n                this.openTag();\n                break;\n            case FORWARD_SLASH:\n                this.state = S_OPEN_TAG_SLASH;\n                break;\n            default:\n                if (!isS(c)) {\n                    this.fail(\"disallowed character in tag name.\");\n                }\n                this.state = S_ATTRIB;\n        }\n    }\n    sOpenTagSlash() {\n        if (this.getCode() === GREATER) {\n            this.openSelfClosingTag();\n        }\n        else {\n            this.fail(\"forward-slash in opening tag not followed by >.\");\n            this.state = S_ATTRIB;\n        }\n    }\n    sAttrib() {\n        const c = this.skipSpaces();\n        if (c === EOC) {\n            return;\n        }\n        if (isNameStartChar(c)) {\n            this.unget();\n            this.state = S_ATTRIB_NAME;\n        }\n        else if (c === GREATER) {\n            this.openTag();\n        }\n        else if (c === FORWARD_SLASH) {\n            this.state = S_OPEN_TAG_SLASH;\n        }\n        else {\n            this.fail(\"disallowed character in attribute name.\");\n        }\n    }\n    sAttribName() {\n        const c = this.captureNameChars();\n        if (c === EQUAL) {\n            this.state = S_ATTRIB_VALUE;\n        }\n        else if (isS(c)) {\n            this.state = S_ATTRIB_NAME_SAW_WHITE;\n        }\n        else if (c === GREATER) {\n            this.fail(\"attribute without value.\");\n            this.pushAttrib(this.name, this.name);\n            this.name = this.text = \"\";\n            this.openTag();\n        }\n        else if (c !== EOC) {\n            this.fail(\"disallowed character in attribute name.\");\n        }\n    }\n    sAttribNameSawWhite() {\n        const c = this.skipSpaces();\n        switch (c) {\n            case EOC:\n                return;\n            case EQUAL:\n                this.state = S_ATTRIB_VALUE;\n                break;\n            default:\n                this.fail(\"attribute without value.\");\n                // Should we do this???\n                // this.tag.attributes[this.name] = \"\";\n                this.text = \"\";\n                this.name = \"\";\n                if (c === GREATER) {\n                    this.openTag();\n                }\n                else if (isNameStartChar(c)) {\n                    this.unget();\n                    this.state = S_ATTRIB_NAME;\n                }\n                else {\n                    this.fail(\"disallowed character in attribute name.\");\n                    this.state = S_ATTRIB;\n                }\n        }\n    }\n    sAttribValue() {\n        const c = this.getCodeNorm();\n        if (isQuote(c)) {\n            this.q = c;\n            this.state = S_ATTRIB_VALUE_QUOTED;\n        }\n        else if (!isS(c)) {\n            this.fail(\"unquoted attribute value.\");\n            this.state = S_ATTRIB_VALUE_UNQUOTED;\n            this.unget();\n        }\n    }\n    sAttribValueQuoted() {\n        // We deliberately do not use captureTo here. The specialized code we use\n        // here is faster than using captureTo.\n        const { q, chunk } = this;\n        let { i: start } = this;\n        // eslint-disable-next-line no-constant-condition\n        while (true) {\n            switch (this.getCode()) {\n                case q:\n                    this.pushAttrib(this.name, this.text + chunk.slice(start, this.prevI));\n                    this.name = this.text = \"\";\n                    this.q = null;\n                    this.state = S_ATTRIB_VALUE_CLOSED;\n                    return;\n                case AMP:\n                    this.text += chunk.slice(start, this.prevI);\n                    this.state = S_ENTITY;\n                    this.entityReturnState = S_ATTRIB_VALUE_QUOTED;\n                    return;\n                case NL:\n                case NL_LIKE:\n                case TAB:\n                    this.text += `${chunk.slice(start, this.prevI)} `;\n                    start = this.i;\n                    break;\n                case LESS:\n                    this.text += chunk.slice(start, this.prevI);\n                    this.fail(\"disallowed character.\");\n                    return;\n                case EOC:\n                    this.text += chunk.slice(start);\n                    return;\n                default:\n            }\n        }\n    }\n    sAttribValueClosed() {\n        const c = this.getCodeNorm();\n        if (isS(c)) {\n            this.state = S_ATTRIB;\n        }\n        else if (c === GREATER) {\n            this.openTag();\n        }\n        else if (c === FORWARD_SLASH) {\n            this.state = S_OPEN_TAG_SLASH;\n        }\n        else if (isNameStartChar(c)) {\n            this.fail(\"no whitespace between attributes.\");\n            this.unget();\n            this.state = S_ATTRIB_NAME;\n        }\n        else {\n            this.fail(\"disallowed character in attribute name.\");\n        }\n    }\n    sAttribValueUnquoted() {\n        // We don't do anything regarding EOL or space handling for unquoted\n        // attributes. We already have failed by the time we get here, and the\n        // contract that saxes upholds states that upon failure, it is not safe to\n        // rely on the data passed to event handlers (other than\n        // ``onerror``). Passing \"bad\" data is not a problem.\n        const c = this.captureTo(ATTRIB_VALUE_UNQUOTED_TERMINATOR);\n        switch (c) {\n            case AMP:\n                this.state = S_ENTITY;\n                this.entityReturnState = S_ATTRIB_VALUE_UNQUOTED;\n                break;\n            case LESS:\n                this.fail(\"disallowed character.\");\n                break;\n            case EOC:\n                break;\n            default:\n                if (this.text.includes(\"]]>\")) {\n                    this.fail(\"the string \\\"]]>\\\" is disallowed in char data.\");\n                }\n                this.pushAttrib(this.name, this.text);\n                this.name = this.text = \"\";\n                if (c === GREATER) {\n                    this.openTag();\n                }\n                else {\n                    this.state = S_ATTRIB;\n                }\n        }\n    }\n    sCloseTag() {\n        const c = this.captureNameChars();\n        if (c === GREATER) {\n            this.closeTag();\n        }\n        else if (isS(c)) {\n            this.state = S_CLOSE_TAG_SAW_WHITE;\n        }\n        else if (c !== EOC) {\n            this.fail(\"disallowed character in closing tag.\");\n        }\n    }\n    sCloseTagSawWhite() {\n        switch (this.skipSpaces()) {\n            case GREATER:\n                this.closeTag();\n                break;\n            case EOC:\n                break;\n            default:\n                this.fail(\"disallowed character in closing tag.\");\n        }\n    }\n    // END OF STATE ENGINE METHODS\n    handleTextInRoot() {\n        // This is essentially a specialized version of captureTo which is optimized\n        // for performing the ]]> check. A previous version of this code, checked\n        // ``this.text`` for the presence of ]]>. It simplified the code but was\n        // very costly when character data contained a lot of entities to be parsed.\n        //\n        // Since we are using a specialized loop, we also keep track of the presence\n        // of ]]> in text data. The sequence ]]> is forbidden to appear as-is.\n        //\n        let { i: start, forbiddenState } = this;\n        const { chunk, textHandler: handler } = this;\n        // eslint-disable-next-line no-labels, no-restricted-syntax\n        scanLoop: \n        // eslint-disable-next-line no-constant-condition\n        while (true) {\n            switch (this.getCode()) {\n                case LESS: {\n                    this.state = S_OPEN_WAKA;\n                    if (handler !== undefined) {\n                        const { text } = this;\n                        const slice = chunk.slice(start, this.prevI);\n                        if (text.length !== 0) {\n                            handler(text + slice);\n                            this.text = \"\";\n                        }\n                        else if (slice.length !== 0) {\n                            handler(slice);\n                        }\n                    }\n                    forbiddenState = FORBIDDEN_START;\n                    // eslint-disable-next-line no-labels\n                    break scanLoop;\n                }\n                case AMP:\n                    this.state = S_ENTITY;\n                    this.entityReturnState = S_TEXT;\n                    if (handler !== undefined) {\n                        this.text += chunk.slice(start, this.prevI);\n                    }\n                    forbiddenState = FORBIDDEN_START;\n                    // eslint-disable-next-line no-labels\n                    break scanLoop;\n                case CLOSE_BRACKET:\n                    switch (forbiddenState) {\n                        case FORBIDDEN_START:\n                            forbiddenState = FORBIDDEN_BRACKET;\n                            break;\n                        case FORBIDDEN_BRACKET:\n                            forbiddenState = FORBIDDEN_BRACKET_BRACKET;\n                            break;\n                        case FORBIDDEN_BRACKET_BRACKET:\n                            break;\n                        default:\n                            throw new Error(\"impossible state\");\n                    }\n                    break;\n                case GREATER:\n                    if (forbiddenState === FORBIDDEN_BRACKET_BRACKET) {\n                        this.fail(\"the string \\\"]]>\\\" is disallowed in char data.\");\n                    }\n                    forbiddenState = FORBIDDEN_START;\n                    break;\n                case NL_LIKE:\n                    if (handler !== undefined) {\n                        this.text += `${chunk.slice(start, this.prevI)}\\n`;\n                    }\n                    start = this.i;\n                    forbiddenState = FORBIDDEN_START;\n                    break;\n                case EOC:\n                    if (handler !== undefined) {\n                        this.text += chunk.slice(start);\n                    }\n                    // eslint-disable-next-line no-labels\n                    break scanLoop;\n                default:\n                    forbiddenState = FORBIDDEN_START;\n            }\n        }\n        this.forbiddenState = forbiddenState;\n    }\n    handleTextOutsideRoot() {\n        // This is essentially a specialized version of captureTo which is optimized\n        // for a specialized task. We keep track of the presence of non-space\n        // characters in the text since these are errors when appearing outside the\n        // document root element.\n        let { i: start } = this;\n        const { chunk, textHandler: handler } = this;\n        let nonSpace = false;\n        // eslint-disable-next-line no-labels, no-restricted-syntax\n        outRootLoop: \n        // eslint-disable-next-line no-constant-condition\n        while (true) {\n            const code = this.getCode();\n            switch (code) {\n                case LESS: {\n                    this.state = S_OPEN_WAKA;\n                    if (handler !== undefined) {\n                        const { text } = this;\n                        const slice = chunk.slice(start, this.prevI);\n                        if (text.length !== 0) {\n                            handler(text + slice);\n                            this.text = \"\";\n                        }\n                        else if (slice.length !== 0) {\n                            handler(slice);\n                        }\n                    }\n                    // eslint-disable-next-line no-labels\n                    break outRootLoop;\n                }\n                case AMP:\n                    this.state = S_ENTITY;\n                    this.entityReturnState = S_TEXT;\n                    if (handler !== undefined) {\n                        this.text += chunk.slice(start, this.prevI);\n                    }\n                    nonSpace = true;\n                    // eslint-disable-next-line no-labels\n                    break outRootLoop;\n                case NL_LIKE:\n                    if (handler !== undefined) {\n                        this.text += `${chunk.slice(start, this.prevI)}\\n`;\n                    }\n                    start = this.i;\n                    break;\n                case EOC:\n                    if (handler !== undefined) {\n                        this.text += chunk.slice(start);\n                    }\n                    // eslint-disable-next-line no-labels\n                    break outRootLoop;\n                default:\n                    if (!isS(code)) {\n                        nonSpace = true;\n                    }\n            }\n        }\n        if (!nonSpace) {\n            return;\n        }\n        // We use the reportedTextBeforeRoot and reportedTextAfterRoot flags\n        // to avoid reporting errors for every single character that is out of\n        // place.\n        if (!this.sawRoot && !this.reportedTextBeforeRoot) {\n            this.fail(\"text data outside of root node.\");\n            this.reportedTextBeforeRoot = true;\n        }\n        if (this.closedRoot && !this.reportedTextAfterRoot) {\n            this.fail(\"text data outside of root node.\");\n            this.reportedTextAfterRoot = true;\n        }\n    }\n    pushAttribNS(name, value) {\n        var _a;\n        const { prefix, local } = this.qname(name);\n        const attr = { name, prefix, local, value };\n        this.attribList.push(attr);\n        (_a = this.attributeHandler) === null || _a === void 0 ? void 0 : _a.call(this, attr);\n        if (prefix === \"xmlns\") {\n            const trimmed = value.trim();\n            if (this.currentXMLVersion === \"1.0\" && trimmed === \"\") {\n                this.fail(\"invalid attempt to undefine prefix in XML 1.0\");\n            }\n            this.topNS[local] = trimmed;\n            nsPairCheck(this, local, trimmed);\n        }\n        else if (name === \"xmlns\") {\n            const trimmed = value.trim();\n            this.topNS[\"\"] = trimmed;\n            nsPairCheck(this, \"\", trimmed);\n        }\n    }\n    pushAttribPlain(name, value) {\n        var _a;\n        const attr = { name, value };\n        this.attribList.push(attr);\n        (_a = this.attributeHandler) === null || _a === void 0 ? void 0 : _a.call(this, attr);\n    }\n    /**\n     * End parsing. This performs final well-formedness checks and resets the\n     * parser to a clean state.\n     *\n     * @returns this\n     */\n    end() {\n        var _a, _b;\n        if (!this.sawRoot) {\n            this.fail(\"document must contain a root element.\");\n        }\n        const { tags } = this;\n        while (tags.length > 0) {\n            const tag = tags.pop();\n            this.fail(`unclosed tag: ${tag.name}`);\n        }\n        if ((this.state !== S_BEGIN) && (this.state !== S_TEXT)) {\n            this.fail(\"unexpected end.\");\n        }\n        const { text } = this;\n        if (text.length !== 0) {\n            (_a = this.textHandler) === null || _a === void 0 ? void 0 : _a.call(this, text);\n            this.text = \"\";\n        }\n        this._closed = true;\n        (_b = this.endHandler) === null || _b === void 0 ? void 0 : _b.call(this);\n        this._init();\n        return this;\n    }\n    /**\n     * Resolve a namespace prefix.\n     *\n     * @param prefix The prefix to resolve.\n     *\n     * @returns The namespace URI or ``undefined`` if the prefix is not defined.\n     */\n    resolve(prefix) {\n        var _a, _b;\n        let uri = this.topNS[prefix];\n        if (uri !== undefined) {\n            return uri;\n        }\n        const { tags } = this;\n        for (let index = tags.length - 1; index >= 0; index--) {\n            uri = tags[index].ns[prefix];\n            if (uri !== undefined) {\n                return uri;\n            }\n        }\n        uri = this.ns[prefix];\n        if (uri !== undefined) {\n            return uri;\n        }\n        return (_b = (_a = this.opt).resolvePrefix) === null || _b === void 0 ? void 0 : _b.call(_a, prefix);\n    }\n    /**\n     * Parse a qname into its prefix and local name parts.\n     *\n     * @param name The name to parse\n     *\n     * @returns\n     */\n    qname(name) {\n        // This is faster than using name.split(\":\").\n        const colon = name.indexOf(\":\");\n        if (colon === -1) {\n            return { prefix: \"\", local: name };\n        }\n        const local = name.slice(colon + 1);\n        const prefix = name.slice(0, colon);\n        if (prefix === \"\" || local === \"\" || local.includes(\":\")) {\n            this.fail(`malformed name: ${name}.`);\n        }\n        return { prefix, local };\n    }\n    processAttribsNS() {\n        var _a;\n        const { attribList } = this;\n        const tag = this.tag;\n        {\n            // add namespace info to tag\n            const { prefix, local } = this.qname(tag.name);\n            tag.prefix = prefix;\n            tag.local = local;\n            const uri = tag.uri = (_a = this.resolve(prefix)) !== null && _a !== void 0 ? _a : \"\";\n            if (prefix !== \"\") {\n                if (prefix === \"xmlns\") {\n                    this.fail(\"tags may not have \\\"xmlns\\\" as prefix.\");\n                }\n                if (uri === \"\") {\n                    this.fail(`unbound namespace prefix: ${JSON.stringify(prefix)}.`);\n                    tag.uri = prefix;\n                }\n            }\n        }\n        if (attribList.length === 0) {\n            return;\n        }\n        const { attributes } = tag;\n        const seen = new Set();\n        // Note: do not apply default ns to attributes:\n        //   http://www.w3.org/TR/REC-xml-names/#defaulting\n        for (const attr of attribList) {\n            const { name, prefix, local } = attr;\n            let uri;\n            let eqname;\n            if (prefix === \"\") {\n                uri = name === \"xmlns\" ? XMLNS_NAMESPACE : \"\";\n                eqname = name;\n            }\n            else {\n                uri = this.resolve(prefix);\n                // if there's any attributes with an undefined namespace,\n                // then fail on them now.\n                if (uri === undefined) {\n                    this.fail(`unbound namespace prefix: ${JSON.stringify(prefix)}.`);\n                    uri = prefix;\n                }\n                eqname = `{${uri}}${local}`;\n            }\n            if (seen.has(eqname)) {\n                this.fail(`duplicate attribute: ${eqname}.`);\n            }\n            seen.add(eqname);\n            attr.uri = uri;\n            attributes[name] = attr;\n        }\n        this.attribList = [];\n    }\n    processAttribsPlain() {\n        const { attribList } = this;\n        // eslint-disable-next-line prefer-destructuring\n        const attributes = this.tag.attributes;\n        for (const { name, value } of attribList) {\n            if (attributes[name] !== undefined) {\n                this.fail(`duplicate attribute: ${name}.`);\n            }\n            attributes[name] = value;\n        }\n        this.attribList = [];\n    }\n    /**\n     * Handle a complete open tag. This parser code calls this once it has seen\n     * the whole tag. This method checks for well-formeness and then emits\n     * ``onopentag``.\n     */\n    openTag() {\n        var _a;\n        this.processAttribs();\n        const { tags } = this;\n        const tag = this.tag;\n        tag.isSelfClosing = false;\n        // There cannot be any pending text here due to the onopentagstart that was\n        // necessarily emitted before we get here. So we do not check text.\n        (_a = this.openTagHandler) === null || _a === void 0 ? void 0 : _a.call(this, tag);\n        tags.push(tag);\n        this.state = S_TEXT;\n        this.name = \"\";\n    }\n    /**\n     * Handle a complete self-closing tag. This parser code calls this once it has\n     * seen the whole tag. This method checks for well-formeness and then emits\n     * ``onopentag`` and ``onclosetag``.\n     */\n    openSelfClosingTag() {\n        var _a, _b, _c;\n        this.processAttribs();\n        const { tags } = this;\n        const tag = this.tag;\n        tag.isSelfClosing = true;\n        // There cannot be any pending text here due to the onopentagstart that was\n        // necessarily emitted before we get here. So we do not check text.\n        (_a = this.openTagHandler) === null || _a === void 0 ? void 0 : _a.call(this, tag);\n        (_b = this.closeTagHandler) === null || _b === void 0 ? void 0 : _b.call(this, tag);\n        const top = this.tag = (_c = tags[tags.length - 1]) !== null && _c !== void 0 ? _c : null;\n        if (top === null) {\n            this.closedRoot = true;\n        }\n        this.state = S_TEXT;\n        this.name = \"\";\n    }\n    /**\n     * Handle a complete close tag. This parser code calls this once it has seen\n     * the whole tag. This method checks for well-formeness and then emits\n     * ``onclosetag``.\n     */\n    closeTag() {\n        const { tags, name } = this;\n        // Our state after this will be S_TEXT, no matter what, and we can clear\n        // tagName now.\n        this.state = S_TEXT;\n        this.name = \"\";\n        if (name === \"\") {\n            this.fail(\"weird empty close tag.\");\n            this.text += \"</>\";\n            return;\n        }\n        const handler = this.closeTagHandler;\n        let l = tags.length;\n        while (l-- > 0) {\n            const tag = this.tag = tags.pop();\n            this.topNS = tag.ns;\n            handler === null || handler === void 0 ? void 0 : handler(tag);\n            if (tag.name === name) {\n                break;\n            }\n            this.fail(\"unexpected close tag.\");\n        }\n        if (l === 0) {\n            this.closedRoot = true;\n        }\n        else if (l < 0) {\n            this.fail(`unmatched closing tag: ${name}.`);\n            this.text += `</${name}>`;\n        }\n    }\n    /**\n     * Resolves an entity. Makes any necessary well-formedness checks.\n     *\n     * @param entity The entity to resolve.\n     *\n     * @returns The parsed entity.\n     */\n    parseEntity(entity) {\n        // startsWith would be significantly slower for this test.\n        if (entity[0] !== \"#\") {\n            const defined = this.ENTITIES[entity];\n            if (defined !== undefined) {\n                return defined;\n            }\n            this.fail(this.isName(entity) ? \"undefined entity.\" :\n                \"disallowed character in entity name.\");\n            return `&${entity};`;\n        }\n        let num = NaN;\n        if (entity[1] === \"x\" && /^#x[0-9a-f]+$/i.test(entity)) {\n            num = parseInt(entity.slice(2), 16);\n        }\n        else if (/^#[0-9]+$/.test(entity)) {\n            num = parseInt(entity.slice(1), 10);\n        }\n        // The character reference is required to match the CHAR production.\n        if (!this.isChar(num)) {\n            this.fail(\"malformed character entity.\");\n            return `&${entity};`;\n        }\n        return String.fromCodePoint(num);\n    }\n}\nexports.SaxesParser = SaxesParser;\n//# sourceMappingURL=saxes.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vc2F4ZXNANi4wLjAvbm9kZV9tb2R1bGVzL3NheGVzL3NheGVzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG1CQUFtQixHQUFHLGNBQWM7QUFDcEMsWUFBWSxtQkFBTyxDQUFDLDRHQUFzQjtBQUMxQyxZQUFZLG1CQUFPLENBQUMsNEdBQXNCO0FBQzFDLGNBQWMsbUJBQU8sQ0FBQyxnSEFBd0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CLDhCQUE4QjtBQUM5QixxQkFBcUI7QUFDckIsMkJBQTJCO0FBQzNCLGlCQUFpQjtBQUNqQix3QkFBd0I7QUFDeEI7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QixnQ0FBZ0M7QUFDaEMsZ0NBQWdDO0FBQ2hDLHFCQUFxQjtBQUNyQiw0QkFBNEI7QUFDNUIsbUJBQW1CO0FBQ25CLHFCQUFxQjtBQUNyQix3QkFBd0I7QUFDeEIsNkJBQTZCO0FBQzdCLHNCQUFzQjtBQUN0Qiw2QkFBNkI7QUFDN0IsNEJBQTRCO0FBQzVCLG9CQUFvQjtBQUNwQiwyQkFBMkI7QUFDM0IsNkJBQTZCO0FBQzdCLDRCQUE0QjtBQUM1QixzQkFBc0I7QUFDdEIsc0JBQXNCO0FBQ3RCLHdCQUF3QjtBQUN4QixrQ0FBa0M7QUFDbEMsNEJBQTRCO0FBQzVCLDBCQUEwQjtBQUMxQixtQ0FBbUM7QUFDbkMsNkJBQTZCO0FBQzdCLGlDQUFpQztBQUNqQyw4QkFBOEI7QUFDOUIsdUJBQXVCO0FBQ3ZCLDZCQUE2QjtBQUM3QixxQkFBcUI7QUFDckIsMEJBQTBCO0FBQzFCLG9DQUFvQztBQUNwQywyQkFBMkI7QUFDM0Isa0NBQWtDO0FBQ2xDLGtDQUFrQztBQUNsQyxvQ0FBb0M7QUFDcEMsd0JBQXdCO0FBQ3hCLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsY0FBYztBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxnQkFBZ0I7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsSUFBSTtBQUMvRDtBQUNBLEVBQUUsZ0JBQWdCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQTJFLElBQUk7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsaUJBQWlCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsY0FBYztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLG9CQUFvQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsVUFBVSxHQUFHLFlBQVk7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHlCQUF5QixFQUFFLE1BQU07QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGFBQWE7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFdBQVc7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0EsZ0JBQWdCLFdBQVc7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsV0FBVztBQUN6QixnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQywrQkFBK0I7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsV0FBVztBQUN6QixnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLCtCQUErQjtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGtCQUFrQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFdBQVc7QUFDekIsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLCtCQUErQjtBQUNyRTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsb0JBQW9CO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsd0JBQXdCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qix3QkFBd0I7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qix3QkFBd0I7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyx3QkFBd0I7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixrQkFBa0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFdBQVc7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsd0JBQXdCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELHVCQUF1QjtBQUMxRTtBQUNBO0FBQ0EsaURBQWlELCtCQUErQjtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFdBQVc7QUFDM0IsY0FBYyxXQUFXO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsZ0NBQWdDO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYywyQkFBMkI7QUFDekMsZ0JBQWdCLDhCQUE4QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLE9BQU87QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QywrQkFBK0I7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxXQUFXO0FBQ3pCLGdCQUFnQiw4QkFBOEI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsT0FBTztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLCtCQUErQjtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGdCQUFnQjtBQUNoQyx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0EsdUNBQXVDLFNBQVM7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCLDBDQUEwQyxZQUFZO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLEtBQUs7QUFDOUM7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGFBQWE7QUFDN0I7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELHVCQUF1QjtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixhQUFhO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELHVCQUF1QjtBQUNsRjtBQUNBO0FBQ0EsMkJBQTJCLEVBQUUsS0FBSyxFQUFFLE1BQU07QUFDMUM7QUFDQTtBQUNBLGtEQUFrRCxPQUFPO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsYUFBYTtBQUM3QjtBQUNBO0FBQ0EscUJBQXFCLGNBQWM7QUFDbkM7QUFDQSxrREFBa0QsS0FBSztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixhQUFhO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxLQUFLO0FBQ3JELDhCQUE4QixLQUFLO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixRQUFRO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsUUFBUTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQiIsInNvdXJjZXMiOlsid2VicGFjazovL2xhbmdjaGFpbi1uZXh0anMtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvLnBucG0vc2F4ZXNANi4wLjAvbm9kZV9tb2R1bGVzL3NheGVzL3NheGVzLmpzPzUxYTgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlNheGVzUGFyc2VyID0gZXhwb3J0cy5FVkVOVFMgPSB2b2lkIDA7XG5jb25zdCBlZDUgPSByZXF1aXJlKFwieG1sY2hhcnMveG1sLzEuMC9lZDVcIik7XG5jb25zdCBlZDIgPSByZXF1aXJlKFwieG1sY2hhcnMveG1sLzEuMS9lZDJcIik7XG5jb25zdCBOU2VkMyA9IHJlcXVpcmUoXCJ4bWxjaGFycy94bWxucy8xLjAvZWQzXCIpO1xudmFyIGlzUyA9IGVkNS5pc1M7XG52YXIgaXNDaGFyMTAgPSBlZDUuaXNDaGFyO1xudmFyIGlzTmFtZVN0YXJ0Q2hhciA9IGVkNS5pc05hbWVTdGFydENoYXI7XG52YXIgaXNOYW1lQ2hhciA9IGVkNS5pc05hbWVDaGFyO1xudmFyIFNfTElTVCA9IGVkNS5TX0xJU1Q7XG52YXIgTkFNRV9SRSA9IGVkNS5OQU1FX1JFO1xudmFyIGlzQ2hhcjExID0gZWQyLmlzQ2hhcjtcbnZhciBpc05DTmFtZVN0YXJ0Q2hhciA9IE5TZWQzLmlzTkNOYW1lU3RhcnRDaGFyO1xudmFyIGlzTkNOYW1lQ2hhciA9IE5TZWQzLmlzTkNOYW1lQ2hhcjtcbnZhciBOQ19OQU1FX1JFID0gTlNlZDMuTkNfTkFNRV9SRTtcbmNvbnN0IFhNTF9OQU1FU1BBQ0UgPSBcImh0dHA6Ly93d3cudzMub3JnL1hNTC8xOTk4L25hbWVzcGFjZVwiO1xuY29uc3QgWE1MTlNfTkFNRVNQQUNFID0gXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3htbG5zL1wiO1xuY29uc3Qgcm9vdE5TID0ge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55LCBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFzc2lnbm1lbnRcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgeG1sOiBYTUxfTkFNRVNQQUNFLFxuICAgIHhtbG5zOiBYTUxOU19OQU1FU1BBQ0UsXG59O1xuY29uc3QgWE1MX0VOVElUSUVTID0ge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55LCBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFzc2lnbm1lbnRcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgYW1wOiBcIiZcIixcbiAgICBndDogXCI+XCIsXG4gICAgbHQ6IFwiPFwiLFxuICAgIHF1b3Q6IFwiXFxcIlwiLFxuICAgIGFwb3M6IFwiJ1wiLFxufTtcbi8vIEVPQzogZW5kLW9mLWNodW5rXG5jb25zdCBFT0MgPSAtMTtcbmNvbnN0IE5MX0xJS0UgPSAtMjtcbmNvbnN0IFNfQkVHSU4gPSAwOyAvLyBJbml0aWFsIHN0YXRlLlxuY29uc3QgU19CRUdJTl9XSElURVNQQUNFID0gMTsgLy8gbGVhZGluZyB3aGl0ZXNwYWNlXG5jb25zdCBTX0RPQ1RZUEUgPSAyOyAvLyA8IURPQ1RZUEVcbmNvbnN0IFNfRE9DVFlQRV9RVU9URSA9IDM7IC8vIDwhRE9DVFlQRSBcIi8vYmxhaFxuY29uc3QgU19EVEQgPSA0OyAvLyA8IURPQ1RZUEUgXCIvL2JsYWhcIiBbIC4uLlxuY29uc3QgU19EVERfUVVPVEVEID0gNTsgLy8gPCFET0NUWVBFIFwiLy9ibGFoXCIgWyBcImZvb1xuY29uc3QgU19EVERfT1BFTl9XQUtBID0gNjtcbmNvbnN0IFNfRFREX09QRU5fV0FLQV9CQU5HID0gNztcbmNvbnN0IFNfRFREX0NPTU1FTlQgPSA4OyAvLyA8IS0tXG5jb25zdCBTX0RURF9DT01NRU5UX0VORElORyA9IDk7IC8vIDwhLS0gYmxhaCAtXG5jb25zdCBTX0RURF9DT01NRU5UX0VOREVEID0gMTA7IC8vIDwhLS0gYmxhaCAtLVxuY29uc3QgU19EVERfUEkgPSAxMTsgLy8gPD9cbmNvbnN0IFNfRFREX1BJX0VORElORyA9IDEyOyAvLyA8P2hpIFwidGhlcmVcIiA/XG5jb25zdCBTX1RFWFQgPSAxMzsgLy8gZ2VuZXJhbCBzdHVmZlxuY29uc3QgU19FTlRJVFkgPSAxNDsgLy8gJmFtcCBhbmQgc3VjaFxuY29uc3QgU19PUEVOX1dBS0EgPSAxNTsgLy8gPFxuY29uc3QgU19PUEVOX1dBS0FfQkFORyA9IDE2OyAvLyA8IS4uLlxuY29uc3QgU19DT01NRU5UID0gMTc7IC8vIDwhLS1cbmNvbnN0IFNfQ09NTUVOVF9FTkRJTkcgPSAxODsgLy8gPCEtLSBibGFoIC1cbmNvbnN0IFNfQ09NTUVOVF9FTkRFRCA9IDE5OyAvLyA8IS0tIGJsYWggLS1cbmNvbnN0IFNfQ0RBVEEgPSAyMDsgLy8gPCFbQ0RBVEFbIHNvbWV0aGluZ1xuY29uc3QgU19DREFUQV9FTkRJTkcgPSAyMTsgLy8gXVxuY29uc3QgU19DREFUQV9FTkRJTkdfMiA9IDIyOyAvLyBdXVxuY29uc3QgU19QSV9GSVJTVF9DSEFSID0gMjM7IC8vIDw/aGksIGZpcnN0IGNoYXJcbmNvbnN0IFNfUElfUkVTVCA9IDI0OyAvLyA8P2hpLCByZXN0IG9mIHRoZSBuYW1lXG5jb25zdCBTX1BJX0JPRFkgPSAyNTsgLy8gPD9oaSB0aGVyZVxuY29uc3QgU19QSV9FTkRJTkcgPSAyNjsgLy8gPD9oaSBcInRoZXJlXCIgP1xuY29uc3QgU19YTUxfREVDTF9OQU1FX1NUQVJUID0gMjc7IC8vIDw/eG1sXG5jb25zdCBTX1hNTF9ERUNMX05BTUUgPSAyODsgLy8gPD94bWwgZm9vXG5jb25zdCBTX1hNTF9ERUNMX0VRID0gMjk7IC8vIDw/eG1sIGZvbz1cbmNvbnN0IFNfWE1MX0RFQ0xfVkFMVUVfU1RBUlQgPSAzMDsgLy8gPD94bWwgZm9vPVxuY29uc3QgU19YTUxfREVDTF9WQUxVRSA9IDMxOyAvLyA8P3htbCBmb289XCJiYXJcIlxuY29uc3QgU19YTUxfREVDTF9TRVBBUkFUT1IgPSAzMjsgLy8gPD94bWwgZm9vPVwiYmFyXCJcbmNvbnN0IFNfWE1MX0RFQ0xfRU5ESU5HID0gMzM7IC8vIDw/eG1sIC4uLiA/XG5jb25zdCBTX09QRU5fVEFHID0gMzQ7IC8vIDxzdHJvbmdcbmNvbnN0IFNfT1BFTl9UQUdfU0xBU0ggPSAzNTsgLy8gPHN0cm9uZyAvXG5jb25zdCBTX0FUVFJJQiA9IDM2OyAvLyA8YVxuY29uc3QgU19BVFRSSUJfTkFNRSA9IDM3OyAvLyA8YSBmb29cbmNvbnN0IFNfQVRUUklCX05BTUVfU0FXX1dISVRFID0gMzg7IC8vIDxhIGZvbyBfXG5jb25zdCBTX0FUVFJJQl9WQUxVRSA9IDM5OyAvLyA8YSBmb289XG5jb25zdCBTX0FUVFJJQl9WQUxVRV9RVU9URUQgPSA0MDsgLy8gPGEgZm9vPVwiYmFyXG5jb25zdCBTX0FUVFJJQl9WQUxVRV9DTE9TRUQgPSA0MTsgLy8gPGEgZm9vPVwiYmFyXCJcbmNvbnN0IFNfQVRUUklCX1ZBTFVFX1VOUVVPVEVEID0gNDI7IC8vIDxhIGZvbz1iYXJcbmNvbnN0IFNfQ0xPU0VfVEFHID0gNDM7IC8vIDwvYVxuY29uc3QgU19DTE9TRV9UQUdfU0FXX1dISVRFID0gNDQ7IC8vIDwvYSAgID5cbmNvbnN0IFRBQiA9IDk7XG5jb25zdCBOTCA9IDB4QTtcbmNvbnN0IENSID0gMHhEO1xuY29uc3QgU1BBQ0UgPSAweDIwO1xuY29uc3QgQkFORyA9IDB4MjE7XG5jb25zdCBEUVVPVEUgPSAweDIyO1xuY29uc3QgQU1QID0gMHgyNjtcbmNvbnN0IFNRVU9URSA9IDB4Mjc7XG5jb25zdCBNSU5VUyA9IDB4MkQ7XG5jb25zdCBGT1JXQVJEX1NMQVNIID0gMHgyRjtcbmNvbnN0IFNFTUlDT0xPTiA9IDB4M0I7XG5jb25zdCBMRVNTID0gMHgzQztcbmNvbnN0IEVRVUFMID0gMHgzRDtcbmNvbnN0IEdSRUFURVIgPSAweDNFO1xuY29uc3QgUVVFU1RJT04gPSAweDNGO1xuY29uc3QgT1BFTl9CUkFDS0VUID0gMHg1QjtcbmNvbnN0IENMT1NFX0JSQUNLRVQgPSAweDVEO1xuY29uc3QgTkVMID0gMHg4NTtcbmNvbnN0IExTID0gMHgyMDI4OyAvLyBMaW5lIFNlcGFyYXRvclxuY29uc3QgaXNRdW90ZSA9IChjKSA9PiBjID09PSBEUVVPVEUgfHwgYyA9PT0gU1FVT1RFO1xuY29uc3QgUVVPVEVTID0gW0RRVU9URSwgU1FVT1RFXTtcbmNvbnN0IERPQ1RZUEVfVEVSTUlOQVRPUiA9IFsuLi5RVU9URVMsIE9QRU5fQlJBQ0tFVCwgR1JFQVRFUl07XG5jb25zdCBEVERfVEVSTUlOQVRPUiA9IFsuLi5RVU9URVMsIExFU1MsIENMT1NFX0JSQUNLRVRdO1xuY29uc3QgWE1MX0RFQ0xfTkFNRV9URVJNSU5BVE9SID0gW0VRVUFMLCBRVUVTVElPTiwgLi4uU19MSVNUXTtcbmNvbnN0IEFUVFJJQl9WQUxVRV9VTlFVT1RFRF9URVJNSU5BVE9SID0gWy4uLlNfTElTVCwgR1JFQVRFUiwgQU1QLCBMRVNTXTtcbmZ1bmN0aW9uIG5zUGFpckNoZWNrKHBhcnNlciwgcHJlZml4LCB1cmkpIHtcbiAgICBzd2l0Y2ggKHByZWZpeCkge1xuICAgICAgICBjYXNlIFwieG1sXCI6XG4gICAgICAgICAgICBpZiAodXJpICE9PSBYTUxfTkFNRVNQQUNFKSB7XG4gICAgICAgICAgICAgICAgcGFyc2VyLmZhaWwoYHhtbCBwcmVmaXggbXVzdCBiZSBib3VuZCB0byAke1hNTF9OQU1FU1BBQ0V9LmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJ4bWxuc1wiOlxuICAgICAgICAgICAgaWYgKHVyaSAhPT0gWE1MTlNfTkFNRVNQQUNFKSB7XG4gICAgICAgICAgICAgICAgcGFyc2VyLmZhaWwoYHhtbG5zIHByZWZpeCBtdXN0IGJlIGJvdW5kIHRvICR7WE1MTlNfTkFNRVNQQUNFfS5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgIH1cbiAgICBzd2l0Y2ggKHVyaSkge1xuICAgICAgICBjYXNlIFhNTE5TX05BTUVTUEFDRTpcbiAgICAgICAgICAgIHBhcnNlci5mYWlsKHByZWZpeCA9PT0gXCJcIiA/XG4gICAgICAgICAgICAgICAgYHRoZSBkZWZhdWx0IG5hbWVzcGFjZSBtYXkgbm90IGJlIHNldCB0byAke3VyaX0uYCA6XG4gICAgICAgICAgICAgICAgYG1heSBub3QgYXNzaWduIGEgcHJlZml4IChldmVuIFwieG1sbnNcIikgdG8gdGhlIFVSSSBcXFxuJHtYTUxOU19OQU1FU1BBQ0V9LmApO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgWE1MX05BTUVTUEFDRTpcbiAgICAgICAgICAgIHN3aXRjaCAocHJlZml4KSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcInhtbFwiOlxuICAgICAgICAgICAgICAgICAgICAvLyBBc3NpbmdpbmcgdGhlIFhNTCBuYW1lc3BhY2UgdG8gXCJ4bWxcIiBpcyBmaW5lLlxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiXCI6XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlci5mYWlsKGB0aGUgZGVmYXVsdCBuYW1lc3BhY2UgbWF5IG5vdCBiZSBzZXQgdG8gJHt1cml9LmApO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBwYXJzZXIuZmFpbChcIm1heSBub3QgYXNzaWduIHRoZSB4bWwgbmFtZXNwYWNlIHRvIGFub3RoZXIgcHJlZml4LlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgIH1cbn1cbmZ1bmN0aW9uIG5zTWFwcGluZ0NoZWNrKHBhcnNlciwgbWFwcGluZykge1xuICAgIGZvciAoY29uc3QgbG9jYWwgb2YgT2JqZWN0LmtleXMobWFwcGluZykpIHtcbiAgICAgICAgbnNQYWlyQ2hlY2socGFyc2VyLCBsb2NhbCwgbWFwcGluZ1tsb2NhbF0pO1xuICAgIH1cbn1cbmNvbnN0IGlzTkNOYW1lID0gKG5hbWUpID0+IE5DX05BTUVfUkUudGVzdChuYW1lKTtcbmNvbnN0IGlzTmFtZSA9IChuYW1lKSA9PiBOQU1FX1JFLnRlc3QobmFtZSk7XG5jb25zdCBGT1JCSURERU5fU1RBUlQgPSAwO1xuY29uc3QgRk9SQklEREVOX0JSQUNLRVQgPSAxO1xuY29uc3QgRk9SQklEREVOX0JSQUNLRVRfQlJBQ0tFVCA9IDI7XG4vKipcbiAqIFRoZSBsaXN0IG9mIHN1cHBvcnRlZCBldmVudHMuXG4gKi9cbmV4cG9ydHMuRVZFTlRTID0gW1xuICAgIFwieG1sZGVjbFwiLFxuICAgIFwidGV4dFwiLFxuICAgIFwicHJvY2Vzc2luZ2luc3RydWN0aW9uXCIsXG4gICAgXCJkb2N0eXBlXCIsXG4gICAgXCJjb21tZW50XCIsXG4gICAgXCJvcGVudGFnc3RhcnRcIixcbiAgICBcImF0dHJpYnV0ZVwiLFxuICAgIFwib3BlbnRhZ1wiLFxuICAgIFwiY2xvc2V0YWdcIixcbiAgICBcImNkYXRhXCIsXG4gICAgXCJlcnJvclwiLFxuICAgIFwiZW5kXCIsXG4gICAgXCJyZWFkeVwiLFxuXTtcbmNvbnN0IEVWRU5UX05BTUVfVE9fSEFORExFUl9OQU1FID0ge1xuICAgIHhtbGRlY2w6IFwieG1sZGVjbEhhbmRsZXJcIixcbiAgICB0ZXh0OiBcInRleHRIYW5kbGVyXCIsXG4gICAgcHJvY2Vzc2luZ2luc3RydWN0aW9uOiBcInBpSGFuZGxlclwiLFxuICAgIGRvY3R5cGU6IFwiZG9jdHlwZUhhbmRsZXJcIixcbiAgICBjb21tZW50OiBcImNvbW1lbnRIYW5kbGVyXCIsXG4gICAgb3BlbnRhZ3N0YXJ0OiBcIm9wZW5UYWdTdGFydEhhbmRsZXJcIixcbiAgICBhdHRyaWJ1dGU6IFwiYXR0cmlidXRlSGFuZGxlclwiLFxuICAgIG9wZW50YWc6IFwib3BlblRhZ0hhbmRsZXJcIixcbiAgICBjbG9zZXRhZzogXCJjbG9zZVRhZ0hhbmRsZXJcIixcbiAgICBjZGF0YTogXCJjZGF0YUhhbmRsZXJcIixcbiAgICBlcnJvcjogXCJlcnJvckhhbmRsZXJcIixcbiAgICBlbmQ6IFwiZW5kSGFuZGxlclwiLFxuICAgIHJlYWR5OiBcInJlYWR5SGFuZGxlclwiLFxufTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXR5cGVzXG5jbGFzcyBTYXhlc1BhcnNlciB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIG9wdCBUaGUgcGFyc2VyIG9wdGlvbnMuXG4gICAgICovXG4gICAgY29uc3RydWN0b3Iob3B0KSB7XG4gICAgICAgIHRoaXMub3B0ID0gb3B0ICE9PSBudWxsICYmIG9wdCAhPT0gdm9pZCAwID8gb3B0IDoge307XG4gICAgICAgIHRoaXMuZnJhZ21lbnRPcHQgPSAhIXRoaXMub3B0LmZyYWdtZW50O1xuICAgICAgICBjb25zdCB4bWxuc09wdCA9IHRoaXMueG1sbnNPcHQgPSAhIXRoaXMub3B0LnhtbG5zO1xuICAgICAgICB0aGlzLnRyYWNrUG9zaXRpb24gPSB0aGlzLm9wdC5wb3NpdGlvbiAhPT0gZmFsc2U7XG4gICAgICAgIHRoaXMuZmlsZU5hbWUgPSB0aGlzLm9wdC5maWxlTmFtZTtcbiAgICAgICAgaWYgKHhtbG5zT3B0KSB7XG4gICAgICAgICAgICAvLyBUaGlzIGlzIHRoZSBmdW5jdGlvbiB3ZSB1c2UgdG8gcGVyZm9ybSBuYW1lIGNoZWNrcyBvbiBQSXMgYW5kIGVudGl0aWVzLlxuICAgICAgICAgICAgLy8gV2hlbiBuYW1lc3BhY2VzIGFyZSB1c2VkLCBjb2xvbnMgYXJlIG5vdCBhbGxvd2VkIGluIFBJIHRhcmdldCBuYW1lcyBvclxuICAgICAgICAgICAgLy8gZW50aXR5IG5hbWVzLiBTbyB0aGUgY2hlY2sgZGVwZW5kcyBvbiB3aGV0aGVyIG5hbWVzcGFjZXMgYXJlIHVzZWQuIFNlZTpcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBodHRwczovL3d3dy53My5vcmcvWE1ML3htbC1uYW1lcy0xOTk5MDExNC1lcnJhdGEuaHRtbFxuICAgICAgICAgICAgLy8gTkUwOFxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIHRoaXMubmFtZVN0YXJ0Q2hlY2sgPSBpc05DTmFtZVN0YXJ0Q2hhcjtcbiAgICAgICAgICAgIHRoaXMubmFtZUNoZWNrID0gaXNOQ05hbWVDaGFyO1xuICAgICAgICAgICAgdGhpcy5pc05hbWUgPSBpc05DTmFtZTtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvdW5ib3VuZC1tZXRob2RcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc0F0dHJpYnMgPSB0aGlzLnByb2Nlc3NBdHRyaWJzTlM7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3VuYm91bmQtbWV0aG9kXG4gICAgICAgICAgICB0aGlzLnB1c2hBdHRyaWIgPSB0aGlzLnB1c2hBdHRyaWJOUztcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55LCBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFzc2lnbm1lbnRcbiAgICAgICAgICAgIHRoaXMubnMgPSBPYmplY3QuYXNzaWduKHsgX19wcm90b19fOiBudWxsIH0sIHJvb3ROUyk7XG4gICAgICAgICAgICBjb25zdCBhZGRpdGlvbmFsID0gdGhpcy5vcHQuYWRkaXRpb25hbE5hbWVzcGFjZXM7XG4gICAgICAgICAgICBpZiAoYWRkaXRpb25hbCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbnNNYXBwaW5nQ2hlY2sodGhpcywgYWRkaXRpb25hbCk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLm5zLCBhZGRpdGlvbmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubmFtZVN0YXJ0Q2hlY2sgPSBpc05hbWVTdGFydENoYXI7XG4gICAgICAgICAgICB0aGlzLm5hbWVDaGVjayA9IGlzTmFtZUNoYXI7XG4gICAgICAgICAgICB0aGlzLmlzTmFtZSA9IGlzTmFtZTtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvdW5ib3VuZC1tZXRob2RcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc0F0dHJpYnMgPSB0aGlzLnByb2Nlc3NBdHRyaWJzUGxhaW47XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3VuYm91bmQtbWV0aG9kXG4gICAgICAgICAgICB0aGlzLnB1c2hBdHRyaWIgPSB0aGlzLnB1c2hBdHRyaWJQbGFpbjtcbiAgICAgICAgfVxuICAgICAgICAvL1xuICAgICAgICAvLyBUaGUgb3JkZXIgb2YgdGhlIG1lbWJlcnMgaW4gdGhpcyB0YWJsZSBuZWVkcyB0byBjb3JyZXNwb25kIHRvIHRoZSBzdGF0ZVxuICAgICAgICAvLyBudW1iZXJzIGdpdmVuIHRvIHRoZSBzdGF0ZXMgdGhhdCBjb3JyZXNwb25kIHRvIHRoZSBtZXRob2RzIGJlaW5nIHJlY29yZGVkXG4gICAgICAgIC8vIGhlcmUuXG4gICAgICAgIC8vXG4gICAgICAgIHRoaXMuc3RhdGVUYWJsZSA9IFtcbiAgICAgICAgICAgIC8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC91bmJvdW5kLW1ldGhvZCAqL1xuICAgICAgICAgICAgdGhpcy5zQmVnaW4sXG4gICAgICAgICAgICB0aGlzLnNCZWdpbldoaXRlc3BhY2UsXG4gICAgICAgICAgICB0aGlzLnNEb2N0eXBlLFxuICAgICAgICAgICAgdGhpcy5zRG9jdHlwZVF1b3RlLFxuICAgICAgICAgICAgdGhpcy5zRFRELFxuICAgICAgICAgICAgdGhpcy5zRFREUXVvdGVkLFxuICAgICAgICAgICAgdGhpcy5zRFRET3Blbldha2EsXG4gICAgICAgICAgICB0aGlzLnNEVERPcGVuV2FrYUJhbmcsXG4gICAgICAgICAgICB0aGlzLnNEVERDb21tZW50LFxuICAgICAgICAgICAgdGhpcy5zRFREQ29tbWVudEVuZGluZyxcbiAgICAgICAgICAgIHRoaXMuc0RURENvbW1lbnRFbmRlZCxcbiAgICAgICAgICAgIHRoaXMuc0RURFBJLFxuICAgICAgICAgICAgdGhpcy5zRFREUElFbmRpbmcsXG4gICAgICAgICAgICB0aGlzLnNUZXh0LFxuICAgICAgICAgICAgdGhpcy5zRW50aXR5LFxuICAgICAgICAgICAgdGhpcy5zT3Blbldha2EsXG4gICAgICAgICAgICB0aGlzLnNPcGVuV2FrYUJhbmcsXG4gICAgICAgICAgICB0aGlzLnNDb21tZW50LFxuICAgICAgICAgICAgdGhpcy5zQ29tbWVudEVuZGluZyxcbiAgICAgICAgICAgIHRoaXMuc0NvbW1lbnRFbmRlZCxcbiAgICAgICAgICAgIHRoaXMuc0NEYXRhLFxuICAgICAgICAgICAgdGhpcy5zQ0RhdGFFbmRpbmcsXG4gICAgICAgICAgICB0aGlzLnNDRGF0YUVuZGluZzIsXG4gICAgICAgICAgICB0aGlzLnNQSUZpcnN0Q2hhcixcbiAgICAgICAgICAgIHRoaXMuc1BJUmVzdCxcbiAgICAgICAgICAgIHRoaXMuc1BJQm9keSxcbiAgICAgICAgICAgIHRoaXMuc1BJRW5kaW5nLFxuICAgICAgICAgICAgdGhpcy5zWE1MRGVjbE5hbWVTdGFydCxcbiAgICAgICAgICAgIHRoaXMuc1hNTERlY2xOYW1lLFxuICAgICAgICAgICAgdGhpcy5zWE1MRGVjbEVxLFxuICAgICAgICAgICAgdGhpcy5zWE1MRGVjbFZhbHVlU3RhcnQsXG4gICAgICAgICAgICB0aGlzLnNYTUxEZWNsVmFsdWUsXG4gICAgICAgICAgICB0aGlzLnNYTUxEZWNsU2VwYXJhdG9yLFxuICAgICAgICAgICAgdGhpcy5zWE1MRGVjbEVuZGluZyxcbiAgICAgICAgICAgIHRoaXMuc09wZW5UYWcsXG4gICAgICAgICAgICB0aGlzLnNPcGVuVGFnU2xhc2gsXG4gICAgICAgICAgICB0aGlzLnNBdHRyaWIsXG4gICAgICAgICAgICB0aGlzLnNBdHRyaWJOYW1lLFxuICAgICAgICAgICAgdGhpcy5zQXR0cmliTmFtZVNhd1doaXRlLFxuICAgICAgICAgICAgdGhpcy5zQXR0cmliVmFsdWUsXG4gICAgICAgICAgICB0aGlzLnNBdHRyaWJWYWx1ZVF1b3RlZCxcbiAgICAgICAgICAgIHRoaXMuc0F0dHJpYlZhbHVlQ2xvc2VkLFxuICAgICAgICAgICAgdGhpcy5zQXR0cmliVmFsdWVVbnF1b3RlZCxcbiAgICAgICAgICAgIHRoaXMuc0Nsb3NlVGFnLFxuICAgICAgICAgICAgdGhpcy5zQ2xvc2VUYWdTYXdXaGl0ZSxcbiAgICAgICAgICAgIC8qIGVzbGludC1lbmFibGUgQHR5cGVzY3JpcHQtZXNsaW50L3VuYm91bmQtbWV0aG9kICovXG4gICAgICAgIF07XG4gICAgICAgIHRoaXMuX2luaXQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHdoZXRoZXIgb3Igbm90IHRoZSBwYXJzZXIgaXMgY2xvc2VkLiBJZiBgYHRydWVgYCwgd2FpdCBmb3JcbiAgICAgKiB0aGUgYGByZWFkeWBgIGV2ZW50IHRvIHdyaXRlIGFnYWluLlxuICAgICAqL1xuICAgIGdldCBjbG9zZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jbG9zZWQ7XG4gICAgfVxuICAgIF9pbml0KCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHRoaXMub3Blbldha2FCYW5nID0gXCJcIjtcbiAgICAgICAgdGhpcy50ZXh0ID0gXCJcIjtcbiAgICAgICAgdGhpcy5uYW1lID0gXCJcIjtcbiAgICAgICAgdGhpcy5waVRhcmdldCA9IFwiXCI7XG4gICAgICAgIHRoaXMuZW50aXR5ID0gXCJcIjtcbiAgICAgICAgdGhpcy5xID0gbnVsbDtcbiAgICAgICAgdGhpcy50YWdzID0gW107XG4gICAgICAgIHRoaXMudGFnID0gbnVsbDtcbiAgICAgICAgdGhpcy50b3BOUyA9IG51bGw7XG4gICAgICAgIHRoaXMuY2h1bmsgPSBcIlwiO1xuICAgICAgICB0aGlzLmNodW5rUG9zaXRpb24gPSAwO1xuICAgICAgICB0aGlzLmkgPSAwO1xuICAgICAgICB0aGlzLnByZXZJID0gMDtcbiAgICAgICAgdGhpcy5jYXJyaWVkRnJvbVByZXZpb3VzID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmZvcmJpZGRlblN0YXRlID0gRk9SQklEREVOX1NUQVJUO1xuICAgICAgICB0aGlzLmF0dHJpYkxpc3QgPSBbXTtcbiAgICAgICAgLy8gVGhlIGxvZ2ljIGlzIG9yZ2FuaXplZCBzbyBhcyB0byBtaW5pbWl6ZSB0aGUgbmVlZCB0byBjaGVja1xuICAgICAgICAvLyB0aGlzLm9wdC5mcmFnbWVudCB3aGlsZSBwYXJzaW5nLlxuICAgICAgICBjb25zdCB7IGZyYWdtZW50T3B0IH0gPSB0aGlzO1xuICAgICAgICB0aGlzLnN0YXRlID0gZnJhZ21lbnRPcHQgPyBTX1RFWFQgOiBTX0JFR0lOO1xuICAgICAgICAvLyBXZSB3YW50IHRoZXNlIHRvIGJlIGFsbCB0cnVlIGlmIHdlIGFyZSBkZWFsaW5nIHdpdGggYSBmcmFnbWVudC5cbiAgICAgICAgdGhpcy5yZXBvcnRlZFRleHRCZWZvcmVSb290ID0gdGhpcy5yZXBvcnRlZFRleHRBZnRlclJvb3QgPSB0aGlzLmNsb3NlZFJvb3QgPVxuICAgICAgICAgICAgdGhpcy5zYXdSb290ID0gZnJhZ21lbnRPcHQ7XG4gICAgICAgIC8vIEFuIFhNTCBkZWNsYXJhdGlvbiBpcyBpbnRpYWxseSBwb3NzaWJsZSBvbmx5IHdoZW4gcGFyc2luZyB3aG9sZVxuICAgICAgICAvLyBkb2N1bWVudHMuXG4gICAgICAgIHRoaXMueG1sRGVjbFBvc3NpYmxlID0gIWZyYWdtZW50T3B0O1xuICAgICAgICB0aGlzLnhtbERlY2xFeHBlY3RzID0gW1widmVyc2lvblwiXTtcbiAgICAgICAgdGhpcy5lbnRpdHlSZXR1cm5TdGF0ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgbGV0IHsgZGVmYXVsdFhNTFZlcnNpb24gfSA9IHRoaXMub3B0O1xuICAgICAgICBpZiAoZGVmYXVsdFhNTFZlcnNpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0LmZvcmNlWE1MVmVyc2lvbiA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImZvcmNlWE1MVmVyc2lvbiBzZXQgYnV0IGRlZmF1bHRYTUxWZXJzaW9uIGlzIG5vdCBzZXRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0WE1MVmVyc2lvbiA9IFwiMS4wXCI7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXRYTUxWZXJzaW9uKGRlZmF1bHRYTUxWZXJzaW9uKTtcbiAgICAgICAgdGhpcy5wb3NpdGlvbkF0TmV3TGluZSA9IDA7XG4gICAgICAgIHRoaXMuZG9jdHlwZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9jbG9zZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy54bWxEZWNsID0ge1xuICAgICAgICAgICAgdmVyc2lvbjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgZW5jb2Rpbmc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHN0YW5kYWxvbmU6IHVuZGVmaW5lZCxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5saW5lID0gMTtcbiAgICAgICAgdGhpcy5jb2x1bW4gPSAwO1xuICAgICAgICB0aGlzLkVOVElUSUVTID0gT2JqZWN0LmNyZWF0ZShYTUxfRU5USVRJRVMpO1xuICAgICAgICAoX2EgPSB0aGlzLnJlYWR5SGFuZGxlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwodGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBzdHJlYW0gcG9zaXRpb24gdGhlIHBhcnNlciBpcyBjdXJyZW50bHkgbG9va2luZyBhdC4gVGhpcyBmaWVsZCBpc1xuICAgICAqIHplcm8tYmFzZWQuXG4gICAgICpcbiAgICAgKiBUaGlzIGZpZWxkIGlzIG5vdCBiYXNlZCBvbiBjb3VudGluZyBVbmljb2RlIGNoYXJhY3RlcnMgYnV0IGlzIHRvIGJlXG4gICAgICogaW50ZXJwcmV0ZWQgYXMgYSBwbGFpbiBpbmRleCBpbnRvIGEgSmF2YVNjcmlwdCBzdHJpbmcuXG4gICAgICovXG4gICAgZ2V0IHBvc2l0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jaHVua1Bvc2l0aW9uICsgdGhpcy5pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgY29sdW1uIG51bWJlciBvZiB0aGUgbmV4dCBjaGFyYWN0ZXIgdG8gYmUgcmVhZCBieSB0aGUgcGFyc2VyLiAgKlxuICAgICAqIFRoaXMgZmllbGQgaXMgemVyby1iYXNlZC4gKFRoZSBmaXJzdCBjb2x1bW4gaW4gYSBsaW5lIGlzIDAuKVxuICAgICAqXG4gICAgICogVGhpcyBmaWVsZCByZXBvcnRzIHRoZSBpbmRleCBhdCB3aGljaCB0aGUgbmV4dCBjaGFyYWN0ZXIgd291bGQgYmUgaW4gdGhlXG4gICAgICogbGluZSBpZiB0aGUgbGluZSB3ZXJlIHJlcHJlc2VudGVkIGFzIGEgSmF2YVNjcmlwdCBzdHJpbmcuICBOb3RlIHRoYXQgdGhpc1xuICAgICAqICpjYW4qIGJlIGRpZmZlcmVudCB0byBhIGNvdW50IGJhc2VkIG9uIHRoZSBudW1iZXIgb2YgKlVuaWNvZGUgY2hhcmFjdGVycypcbiAgICAgKiBkdWUgdG8gaG93IEphdmFTY3JpcHQgaGFuZGxlcyBhc3RyYWwgcGxhbmUgY2hhcmFjdGVycy5cbiAgICAgKlxuICAgICAqIFNlZSBbW2NvbHVtbl1dIGZvciBhIG51bWJlciB0aGF0IGNvcnJlc3BvbmRzIHRvIGEgY291bnQgb2YgVW5pY29kZVxuICAgICAqIGNoYXJhY3RlcnMuXG4gICAgICovXG4gICAgZ2V0IGNvbHVtbkluZGV4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wb3NpdGlvbiAtIHRoaXMucG9zaXRpb25BdE5ld0xpbmU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCBhbiBldmVudCBsaXN0ZW5lciBvbiBhbiBldmVudC4gVGhlIHBhcnNlciBzdXBwb3J0cyBvbmUgaGFuZGxlciBwZXJcbiAgICAgKiBldmVudCB0eXBlLiBJZiB5b3UgdHJ5IHRvIHNldCBhbiBldmVudCBoYW5kbGVyIG92ZXIgYW4gZXhpc3RpbmcgaGFuZGxlcixcbiAgICAgKiB0aGUgb2xkIGhhbmRsZXIgaXMgc2lsZW50bHkgb3ZlcndyaXR0ZW4uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbmFtZSBUaGUgZXZlbnQgdG8gbGlzdGVuIHRvLlxuICAgICAqXG4gICAgICogQHBhcmFtIGhhbmRsZXIgVGhlIGhhbmRsZXIgdG8gc2V0LlxuICAgICAqL1xuICAgIG9uKG5hbWUsIGhhbmRsZXIpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnksIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtbWVtYmVyLWFjY2Vzc1xuICAgICAgICB0aGlzW0VWRU5UX05BTUVfVE9fSEFORExFUl9OQU1FW25hbWVdXSA9IGhhbmRsZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVuc2V0IGFuIGV2ZW50IGhhbmRsZXIuXG4gICAgICpcbiAgICAgKiBAcGFybWEgbmFtZSBUaGUgZXZlbnQgdG8gc3RvcCBsaXN0ZW5pbmcgdG8uXG4gICAgICovXG4gICAgb2ZmKG5hbWUpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnksIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtbWVtYmVyLWFjY2Vzc1xuICAgICAgICB0aGlzW0VWRU5UX05BTUVfVE9fSEFORExFUl9OQU1FW25hbWVdXSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWFrZSBhbiBlcnJvciBvYmplY3QuIFRoZSBlcnJvciBvYmplY3Qgd2lsbCBoYXZlIGEgbWVzc2FnZSB0aGF0IGNvbnRhaW5zXG4gICAgICogdGhlIGBgZmlsZU5hbWVgYCBvcHRpb24gcGFzc2VkIGF0IHRoZSBjcmVhdGlvbiBvZiB0aGUgcGFyc2VyLiBJZiBwb3NpdGlvblxuICAgICAqIHRyYWNraW5nIHdhcyB0dXJuZWQgb24sIGl0IHdpbGwgYWxzbyBoYXZlIGxpbmUgYW5kIGNvbHVtbiBudW1iZXJcbiAgICAgKiBpbmZvcm1hdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBtZXNzYWdlIFRoZSBtZXNzYWdlIGRlc2NyaWJpbmcgdGhlIGVycm9yIHRvIHJlcG9ydC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEFuIGVycm9yIG9iamVjdCB3aXRoIGEgcHJvcGVybHkgZm9ybWF0dGVkIG1lc3NhZ2UuXG4gICAgICovXG4gICAgbWFrZUVycm9yKG1lc3NhZ2UpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBsZXQgbXNnID0gKF9hID0gdGhpcy5maWxlTmFtZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogXCJcIjtcbiAgICAgICAgaWYgKHRoaXMudHJhY2tQb3NpdGlvbikge1xuICAgICAgICAgICAgaWYgKG1zZy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgbXNnICs9IFwiOlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbXNnICs9IGAke3RoaXMubGluZX06JHt0aGlzLmNvbHVtbn1gO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtc2cubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgbXNnICs9IFwiOiBcIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEVycm9yKG1zZyArIG1lc3NhZ2UpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXBvcnQgYSBwYXJzaW5nIGVycm9yLiBUaGlzIG1ldGhvZCBpcyBtYWRlIHB1YmxpYyBzbyB0aGF0IGNsaWVudCBjb2RlIG1heVxuICAgICAqIGNoZWNrIGZvciBpc3N1ZXMgdGhhdCBhcmUgb3V0c2lkZSB0aGUgc2NvcGUgb2YgdGhpcyBwcm9qZWN0IGFuZCBjYW4gcmVwb3J0XG4gICAgICogZXJyb3JzLlxuICAgICAqXG4gICAgICogQHBhcmFtIG1lc3NhZ2UgVGhlIGVycm9yIHRvIHJlcG9ydC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHRoaXNcbiAgICAgKi9cbiAgICBmYWlsKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3QgZXJyID0gdGhpcy5tYWtlRXJyb3IobWVzc2FnZSk7XG4gICAgICAgIGNvbnN0IGhhbmRsZXIgPSB0aGlzLmVycm9ySGFuZGxlcjtcbiAgICAgICAgaWYgKGhhbmRsZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaGFuZGxlcihlcnIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcml0ZSBhIFhNTCBkYXRhIHRvIHRoZSBwYXJzZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY2h1bmsgVGhlIFhNTCBkYXRhIHRvIHdyaXRlLlxuICAgICAqXG4gICAgICogQHJldHVybnMgdGhpc1xuICAgICAqL1xuICAgIC8vIFdlIGRvIG5lZWQgb2JqZWN0IGZvciB0aGUgdHlwZSBoZXJlLiBZZXMsIGl0IG9mdGVuIGNhdXNlcyBwcm9ibGVtc1xuICAgIC8vIGJ1dCBub3QgaW4gdGhpcyBjYXNlLlxuICAgIHdyaXRlKGNodW5rKSB7XG4gICAgICAgIGlmICh0aGlzLmNsb3NlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmFpbChcImNhbm5vdCB3cml0ZSBhZnRlciBjbG9zZTsgYXNzaWduIGFuIG9ucmVhZHkgaGFuZGxlci5cIik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGVuZCA9IGZhbHNlO1xuICAgICAgICBpZiAoY2h1bmsgPT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIFdlIGNhbm5vdCByZXR1cm4gaW1tZWRpYXRlbHkgYmVjYXVzZSBjYXJyaWVkRnJvbVByZXZpb3VzIG1heSBuZWVkXG4gICAgICAgICAgICAvLyBwcm9jZXNzaW5nLlxuICAgICAgICAgICAgZW5kID0gdHJ1ZTtcbiAgICAgICAgICAgIGNodW5rID0gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgY2h1bmsgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIGNodW5rID0gY2h1bmsudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBXZSBjaGVja2VkIGlmIHBlcmZvcm1pbmcgYSBwcmUtZGVjb21wb3NpdGlvbiBvZiB0aGUgc3RyaW5nIGludG8gYW4gYXJyYXlcbiAgICAgICAgLy8gb2Ygc2luZ2xlIGNvbXBsZXRlIGNoYXJhY3RlcnMgKGBgQXJyYXkuZnJvbShjaHVuaylgYCkgd291bGQgYmUgZmFzdGVyXG4gICAgICAgIC8vIHRoYW4gdGhlIGN1cnJlbnQgcmVwZWF0ZWQgY2FsbHMgdG8gYGBjaGFyQ29kZUF0YGAuIEFzIG9mIEF1Z3VzdCAyMDE4LCBpdFxuICAgICAgICAvLyBpc24ndC4gKFRoZXJlIG1heSBiZSBOb2RlLXNwZWNpZmljIGNvZGUgdGhhdCB3b3VsZCBwZXJmb3JtIGZhc3RlciB0aGFuXG4gICAgICAgIC8vIGBgQXJyYXkuZnJvbWBgIGJ1dCBkb24ndCB3YW50IHRvIGJlIGRlcGVuZGVudCBvbiBOb2RlLilcbiAgICAgICAgaWYgKHRoaXMuY2FycmllZEZyb21QcmV2aW91cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBUaGUgcHJldmlvdXMgY2h1bmsgaGFkIGNoYXIgd2UgbXVzdCBjYXJyeSBvdmVyLlxuICAgICAgICAgICAgY2h1bmsgPSBgJHt0aGlzLmNhcnJpZWRGcm9tUHJldmlvdXN9JHtjaHVua31gO1xuICAgICAgICAgICAgdGhpcy5jYXJyaWVkRnJvbVByZXZpb3VzID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGxldCBsaW1pdCA9IGNodW5rLmxlbmd0aDtcbiAgICAgICAgY29uc3QgbGFzdENvZGUgPSBjaHVuay5jaGFyQ29kZUF0KGxpbWl0IC0gMSk7XG4gICAgICAgIGlmICghZW5kICYmXG4gICAgICAgICAgICAvLyBBIHRyYWlsaW5nIENSIG9yIHN1cnJvZ2F0ZSBtdXN0IGJlIGNhcnJpZWQgb3ZlciB0byB0aGUgbmV4dFxuICAgICAgICAgICAgLy8gY2h1bmsuXG4gICAgICAgICAgICAobGFzdENvZGUgPT09IENSIHx8IChsYXN0Q29kZSA+PSAweEQ4MDAgJiYgbGFzdENvZGUgPD0gMHhEQkZGKSkpIHtcbiAgICAgICAgICAgIC8vIFRoZSBjaHVuayBlbmRzIHdpdGggYSBjaGFyYWN0ZXIgdGhhdCBtdXN0IGJlIGNhcnJpZWQgb3Zlci4gV2UgY2Fubm90XG4gICAgICAgICAgICAvLyBrbm93IGhvdyB0byBoYW5kbGUgaXQgdW50aWwgd2UgZ2V0IHRoZSBuZXh0IGNodW5rIG9yIHRoZSBlbmQgb2YgdGhlXG4gICAgICAgICAgICAvLyBzdHJlYW0uIFNvIHNhdmUgaXQgZm9yIGxhdGVyLlxuICAgICAgICAgICAgdGhpcy5jYXJyaWVkRnJvbVByZXZpb3VzID0gY2h1bmtbbGltaXQgLSAxXTtcbiAgICAgICAgICAgIGxpbWl0LS07XG4gICAgICAgICAgICBjaHVuayA9IGNodW5rLnNsaWNlKDAsIGxpbWl0KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IHN0YXRlVGFibGUgfSA9IHRoaXM7XG4gICAgICAgIHRoaXMuY2h1bmsgPSBjaHVuaztcbiAgICAgICAgdGhpcy5pID0gMDtcbiAgICAgICAgd2hpbGUgKHRoaXMuaSA8IGxpbWl0KSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSwgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hcmd1bWVudFxuICAgICAgICAgICAgc3RhdGVUYWJsZVt0aGlzLnN0YXRlXS5jYWxsKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2h1bmtQb3NpdGlvbiArPSBsaW1pdDtcbiAgICAgICAgcmV0dXJuIGVuZCA/IHRoaXMuZW5kKCkgOiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbG9zZSB0aGUgY3VycmVudCBzdHJlYW0uIFBlcmZvcm0gZmluYWwgd2VsbC1mb3JtZWRuZXNzIGNoZWNrcyBhbmQgcmVzZXRcbiAgICAgKiB0aGUgcGFyc2VyIHRzdGF0ZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHRoaXNcbiAgICAgKi9cbiAgICBjbG9zZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud3JpdGUobnVsbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBhIHNpbmdsZSBjb2RlIHBvaW50IG91dCBvZiB0aGUgY3VycmVudCBjaHVuay4gVGhpcyB1cGRhdGVzIHRoZSBjdXJyZW50XG4gICAgICogcG9zaXRpb24gaWYgd2UgZG8gcG9zaXRpb24gdHJhY2tpbmcuXG4gICAgICpcbiAgICAgKiBUaGlzIGlzIHRoZSBhbGdvcml0aG0gdG8gdXNlIGZvciBYTUwgMS4wLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIGNoYXJhY3RlciByZWFkLlxuICAgICAqL1xuICAgIGdldENvZGUxMCgpIHtcbiAgICAgICAgY29uc3QgeyBjaHVuaywgaSB9ID0gdGhpcztcbiAgICAgICAgdGhpcy5wcmV2SSA9IGk7XG4gICAgICAgIC8vIFllcywgd2UgZG8gdGhpcyBpbnN0ZWFkIG9mIGRvaW5nIHRoaXMuaSsrLiBEb2luZyBpdCB0aGlzIHdheSwgd2UgZG8gbm90XG4gICAgICAgIC8vIHJlYWQgdGhpcy5pIGFnYWluLCB3aGljaCBpcyBhIGJpdCBmYXN0ZXIuXG4gICAgICAgIHRoaXMuaSA9IGkgKyAxO1xuICAgICAgICBpZiAoaSA+PSBjaHVuay5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBFT0M7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVXNpbmcgY2hhckNvZGVBdCBhbmQgaGFuZGxpbmcgdGhlIHN1cnJvZ2F0ZXMgb3Vyc2VsdmVzIGlzIGZhc3RlclxuICAgICAgICAvLyB0aGFuIHVzaW5nIGNvZGVQb2ludEF0LlxuICAgICAgICBjb25zdCBjb2RlID0gY2h1bmsuY2hhckNvZGVBdChpKTtcbiAgICAgICAgdGhpcy5jb2x1bW4rKztcbiAgICAgICAgaWYgKGNvZGUgPCAweEQ4MDApIHtcbiAgICAgICAgICAgIGlmIChjb2RlID49IFNQQUNFIHx8IGNvZGUgPT09IFRBQikge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3dpdGNoIChjb2RlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBOTDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5saW5lKys7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29sdW1uID0gMDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wb3NpdGlvbkF0TmV3TGluZSA9IHRoaXMucG9zaXRpb247XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBOTDtcbiAgICAgICAgICAgICAgICBjYXNlIENSOlxuICAgICAgICAgICAgICAgICAgICAvLyBXZSBtYXkgZ2V0IE5hTiBpZiB3ZSByZWFkIHBhc3QgdGhlIGVuZCBvZiB0aGUgY2h1bmssIHdoaWNoIGlzIGZpbmUuXG4gICAgICAgICAgICAgICAgICAgIGlmIChjaHVuay5jaGFyQ29kZUF0KGkgKyAxKSA9PT0gTkwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEEgXFxyXFxuIHNlcXVlbmNlIGlzIGNvbnZlcnRlZCB0byBcXG4gc28gd2UgaGF2ZSB0byBza2lwIG92ZXIgdGhlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBuZXh0IGNoYXJhY3Rlci4gV2UgYWxyZWFkeSBrbm93IGl0IGhhcyBhIHNpemUgb2YgMSBzbyArKyBpcyBmaW5lXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBoZXJlLlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pID0gaSArIDI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCBhIFxcciBpcyBqdXN0IGNvbnZlcnRlZCB0byBcXG4sIHNvIHdlIGRvbid0IGhhdmUgdG8gc2tpcFxuICAgICAgICAgICAgICAgICAgICAvLyBhaGVhZC5cbiAgICAgICAgICAgICAgICAgICAgLy8gSW4gZWl0aGVyIGNhc2UsIFxcciBiZWNvbWVzIFxcbi5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5saW5lKys7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29sdW1uID0gMDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wb3NpdGlvbkF0TmV3TGluZSA9IHRoaXMucG9zaXRpb247XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBOTF9MSUtFO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHdlIGdldCBoZXJlLCB0aGVuIGNvZGUgPCBTUEFDRSBhbmQgaXQgaXMgbm90IE5MIENSIG9yIFRBQi5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mYWlsKFwiZGlzYWxsb3dlZCBjaGFyYWN0ZXIuXCIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY29kZSA+IDB4REJGRikge1xuICAgICAgICAgICAgLy8gVGhpcyBpcyBhIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgaXNDaGFyMTAgdGhhdCB0YWtlcyBpbnRvIGFjY291bnRcbiAgICAgICAgICAgIC8vIHRoYXQgaW4gdGhpcyBjb250ZXh0IGNvZGUgPiAweERCRkYgYW5kIGNvZGUgPD0gMHhGRkZGLiBTbyBpdCBkb2VzIG5vdFxuICAgICAgICAgICAgLy8gdGVzdCBjYXNlcyB0aGF0IGRvbid0IG5lZWQgdGVzdGluZy5cbiAgICAgICAgICAgIGlmICghKGNvZGUgPj0gMHhFMDAwICYmIGNvZGUgPD0gMHhGRkZEKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZmFpbChcImRpc2FsbG93ZWQgY2hhcmFjdGVyLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjb2RlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZpbmFsID0gMHgxMDAwMCArICgoY29kZSAtIDB4RDgwMCkgKiAweDQwMCkgK1xuICAgICAgICAgICAgKGNodW5rLmNoYXJDb2RlQXQoaSArIDEpIC0gMHhEQzAwKTtcbiAgICAgICAgdGhpcy5pID0gaSArIDI7XG4gICAgICAgIC8vIFRoaXMgaXMgYSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGlzQ2hhcjEwIHRoYXQgdGFrZXMgaW50byBhY2NvdW50IHRoYXQgaW5cbiAgICAgICAgLy8gdGhpcyBjb250ZXh0IG5lY2Vzc2FyaWx5IGZpbmFsID49IDB4MTAwMDAuXG4gICAgICAgIGlmIChmaW5hbCA+IDB4MTBGRkZGKSB7XG4gICAgICAgICAgICB0aGlzLmZhaWwoXCJkaXNhbGxvd2VkIGNoYXJhY3Rlci5cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZpbmFsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgYSBzaW5nbGUgY29kZSBwb2ludCBvdXQgb2YgdGhlIGN1cnJlbnQgY2h1bmsuIFRoaXMgdXBkYXRlcyB0aGUgY3VycmVudFxuICAgICAqIHBvc2l0aW9uIGlmIHdlIGRvIHBvc2l0aW9uIHRyYWNraW5nLlxuICAgICAqXG4gICAgICogVGhpcyBpcyB0aGUgYWxnb3JpdGhtIHRvIHVzZSBmb3IgWE1MIDEuMS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBjaGFyYWN0ZXIgcmVhZC5cbiAgICAgKi9cbiAgICBnZXRDb2RlMTEoKSB7XG4gICAgICAgIGNvbnN0IHsgY2h1bmssIGkgfSA9IHRoaXM7XG4gICAgICAgIHRoaXMucHJldkkgPSBpO1xuICAgICAgICAvLyBZZXMsIHdlIGRvIHRoaXMgaW5zdGVhZCBvZiBkb2luZyB0aGlzLmkrKy4gRG9pbmcgaXQgdGhpcyB3YXksIHdlIGRvIG5vdFxuICAgICAgICAvLyByZWFkIHRoaXMuaSBhZ2Fpbiwgd2hpY2ggaXMgYSBiaXQgZmFzdGVyLlxuICAgICAgICB0aGlzLmkgPSBpICsgMTtcbiAgICAgICAgaWYgKGkgPj0gY2h1bmsubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gRU9DO1xuICAgICAgICB9XG4gICAgICAgIC8vIFVzaW5nIGNoYXJDb2RlQXQgYW5kIGhhbmRsaW5nIHRoZSBzdXJyb2dhdGVzIG91cnNlbHZlcyBpcyBmYXN0ZXJcbiAgICAgICAgLy8gdGhhbiB1c2luZyBjb2RlUG9pbnRBdC5cbiAgICAgICAgY29uc3QgY29kZSA9IGNodW5rLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIHRoaXMuY29sdW1uKys7XG4gICAgICAgIGlmIChjb2RlIDwgMHhEODAwKSB7XG4gICAgICAgICAgICBpZiAoKGNvZGUgPiAweDFGICYmIGNvZGUgPCAweDdGKSB8fCAoY29kZSA+IDB4OUYgJiYgY29kZSAhPT0gTFMpIHx8XG4gICAgICAgICAgICAgICAgY29kZSA9PT0gVEFCKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzd2l0Y2ggKGNvZGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIE5MOiAvLyAweEFcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5saW5lKys7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29sdW1uID0gMDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wb3NpdGlvbkF0TmV3TGluZSA9IHRoaXMucG9zaXRpb247XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBOTDtcbiAgICAgICAgICAgICAgICBjYXNlIENSOiB7IC8vIDB4RFxuICAgICAgICAgICAgICAgICAgICAvLyBXZSBtYXkgZ2V0IE5hTiBpZiB3ZSByZWFkIHBhc3QgdGhlIGVuZCBvZiB0aGUgY2h1bmssIHdoaWNoIGlzXG4gICAgICAgICAgICAgICAgICAgIC8vIGZpbmUuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5leHQgPSBjaHVuay5jaGFyQ29kZUF0KGkgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5leHQgPT09IE5MIHx8IG5leHQgPT09IE5FTCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQSBDUiBOTCBvciBDUiBORUwgc2VxdWVuY2UgaXMgY29udmVydGVkIHRvIE5MIHNvIHdlIGhhdmUgdG8gc2tpcFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gb3ZlciB0aGUgbmV4dCBjaGFyYWN0ZXIuIFdlIGFscmVhZHkga25vdyBpdCBoYXMgYSBzaXplIG9mIDEuXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmkgPSBpICsgMjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2UsIGEgQ1IgaXMganVzdCBjb252ZXJ0ZWQgdG8gTkwsIG5vIHNraXAuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8qIHllcywgZmFsbCB0aHJvdWdoICovXG4gICAgICAgICAgICAgICAgY2FzZSBORUw6IC8vIDB4ODVcbiAgICAgICAgICAgICAgICBjYXNlIExTOiAvLyBPeDIwMjhcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5saW5lKys7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29sdW1uID0gMDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wb3NpdGlvbkF0TmV3TGluZSA9IHRoaXMucG9zaXRpb247XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBOTF9MSUtFO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmFpbChcImRpc2FsbG93ZWQgY2hhcmFjdGVyLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvZGUgPiAweERCRkYpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgYSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGlzQ2hhckFuZE5vdFJlc3RyaWN0ZWQgdGhhdCB0YWtlcyBpbnRvXG4gICAgICAgICAgICAvLyBhY2NvdW50IHRoYXQgaW4gdGhpcyBjb250ZXh0IGNvZGUgPiAweERCRkYgYW5kIGNvZGUgPD0gMHhGRkZGLiBTbyBpdFxuICAgICAgICAgICAgLy8gZG9lcyBub3QgdGVzdCBjYXNlcyB0aGF0IGRvbid0IG5lZWQgdGVzdGluZy5cbiAgICAgICAgICAgIGlmICghKGNvZGUgPj0gMHhFMDAwICYmIGNvZGUgPD0gMHhGRkZEKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZmFpbChcImRpc2FsbG93ZWQgY2hhcmFjdGVyLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjb2RlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZpbmFsID0gMHgxMDAwMCArICgoY29kZSAtIDB4RDgwMCkgKiAweDQwMCkgK1xuICAgICAgICAgICAgKGNodW5rLmNoYXJDb2RlQXQoaSArIDEpIC0gMHhEQzAwKTtcbiAgICAgICAgdGhpcy5pID0gaSArIDI7XG4gICAgICAgIC8vIFRoaXMgaXMgYSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGlzQ2hhckFuZE5vdFJlc3RyaWN0ZWQgdGhhdCB0YWtlcyBpbnRvXG4gICAgICAgIC8vIGFjY291bnQgdGhhdCBpbiB0aGlzIGNvbnRleHQgbmVjZXNzYXJpbHkgZmluYWwgPj0gMHgxMDAwMC5cbiAgICAgICAgaWYgKGZpbmFsID4gMHgxMEZGRkYpIHtcbiAgICAgICAgICAgIHRoaXMuZmFpbChcImRpc2FsbG93ZWQgY2hhcmFjdGVyLlwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmluYWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExpa2UgYGBnZXRDb2RlYGAgYnV0IHdpdGggdGhlIHJldHVybiB2YWx1ZSBub3JtYWxpemVkIHNvIHRoYXQgYGBOTGBgIGlzXG4gICAgICogcmV0dXJuZWQgZm9yIGBgTkxfTElLRWBgLlxuICAgICAqL1xuICAgIGdldENvZGVOb3JtKCkge1xuICAgICAgICBjb25zdCBjID0gdGhpcy5nZXRDb2RlKCk7XG4gICAgICAgIHJldHVybiBjID09PSBOTF9MSUtFID8gTkwgOiBjO1xuICAgIH1cbiAgICB1bmdldCgpIHtcbiAgICAgICAgdGhpcy5pID0gdGhpcy5wcmV2STtcbiAgICAgICAgdGhpcy5jb2x1bW4tLTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FwdHVyZSBjaGFyYWN0ZXJzIGludG8gYSBidWZmZXIgdW50aWwgZW5jb3VudGVyaW5nIG9uZSBvZiBhIHNldCBvZlxuICAgICAqIGNoYXJhY3RlcnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY2hhcnMgQW4gYXJyYXkgb2YgY29kZXBvaW50cy4gRW5jb3VudGVyaW5nIGEgY2hhcmFjdGVyIGluIHRoZSBhcnJheVxuICAgICAqIGVuZHMgdGhlIGNhcHR1cmUuIChgYGNoYXJzYGAgbWF5IHNhZmVseSBjb250YWluIGBgTkxgYC4pXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIFRoZSBjaGFyYWN0ZXIgY29kZSB0aGF0IG1hZGUgdGhlIGNhcHR1cmUgZW5kLCBvciBgYEVPQ2BgIGlmIHdlIGhpdFxuICAgICAqIHRoZSBlbmQgb2YgdGhlIGNodW5rLiBUaGUgcmV0dXJuIHZhbHVlIGNhbm5vdCBiZSBOTF9MSUtFOiBOTCBpcyByZXR1cm5lZFxuICAgICAqIGluc3RlYWQuXG4gICAgICovXG4gICAgY2FwdHVyZVRvKGNoYXJzKSB7XG4gICAgICAgIGxldCB7IGk6IHN0YXJ0IH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB7IGNodW5rIH0gPSB0aGlzO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc3RhbnQtY29uZGl0aW9uXG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBjb25zdCBjID0gdGhpcy5nZXRDb2RlKCk7XG4gICAgICAgICAgICBjb25zdCBpc05MTGlrZSA9IGMgPT09IE5MX0xJS0U7XG4gICAgICAgICAgICBjb25zdCBmaW5hbCA9IGlzTkxMaWtlID8gTkwgOiBjO1xuICAgICAgICAgICAgaWYgKGZpbmFsID09PSBFT0MgfHwgY2hhcnMuaW5jbHVkZXMoZmluYWwpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50ZXh0ICs9IGNodW5rLnNsaWNlKHN0YXJ0LCB0aGlzLnByZXZJKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmluYWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNOTExpa2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRleHQgKz0gYCR7Y2h1bmsuc2xpY2Uoc3RhcnQsIHRoaXMucHJldkkpfVxcbmA7XG4gICAgICAgICAgICAgICAgc3RhcnQgPSB0aGlzLmk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FwdHVyZSBjaGFyYWN0ZXJzIGludG8gYSBidWZmZXIgdW50aWwgZW5jb3VudGVyaW5nIGEgY2hhcmFjdGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNoYXIgVGhlIGNvZGVwb2ludCB0aGF0IGVuZHMgdGhlIGNhcHR1cmUuICoqTk9URSBgYGNoYXJgYCBNQVkgTk9UXG4gICAgICogQ09OVEFJTiBgYE5MYGAuKiogUGFzc2luZyBgYE5MYGAgd2lsbCByZXN1bHQgaW4gYnVnZ3kgYmVoYXZpb3IuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIGBgdHJ1ZWBgIGlmIHdlIHJhbiBpbnRvIHRoZSBjaGFyYWN0ZXIuIE90aGVyd2lzZSwgd2UgcmFuIGludG8gdGhlXG4gICAgICogZW5kIG9mIHRoZSBjdXJyZW50IGNodW5rLlxuICAgICAqL1xuICAgIGNhcHR1cmVUb0NoYXIoY2hhcikge1xuICAgICAgICBsZXQgeyBpOiBzdGFydCB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgeyBjaHVuayB9ID0gdGhpcztcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnN0YW50LWNvbmRpdGlvblxuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgbGV0IGMgPSB0aGlzLmdldENvZGUoKTtcbiAgICAgICAgICAgIHN3aXRjaCAoYykge1xuICAgICAgICAgICAgICAgIGNhc2UgTkxfTElLRTpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50ZXh0ICs9IGAke2NodW5rLnNsaWNlKHN0YXJ0LCB0aGlzLnByZXZJKX1cXG5gO1xuICAgICAgICAgICAgICAgICAgICBzdGFydCA9IHRoaXMuaTtcbiAgICAgICAgICAgICAgICAgICAgYyA9IE5MO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIEVPQzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50ZXh0ICs9IGNodW5rLnNsaWNlKHN0YXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYyA9PT0gY2hhcikge1xuICAgICAgICAgICAgICAgIHRoaXMudGV4dCArPSBjaHVuay5zbGljZShzdGFydCwgdGhpcy5wcmV2SSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FwdHVyZSBjaGFyYWN0ZXJzIHRoYXQgc2F0aXNmeSBgYGlzTmFtZUNoYXJgYCBpbnRvIHRoZSBgYG5hbWVgYCBmaWVsZCBvZlxuICAgICAqIHRoaXMgcGFyc2VyLlxuICAgICAqXG4gICAgICogQHJldHVybiBUaGUgY2hhcmFjdGVyIGNvZGUgdGhhdCBtYWRlIHRoZSB0ZXN0IGZhaWwsIG9yIGBgRU9DYGAgaWYgd2UgaGl0XG4gICAgICogdGhlIGVuZCBvZiB0aGUgY2h1bmsuIFRoZSByZXR1cm4gdmFsdWUgY2Fubm90IGJlIE5MX0xJS0U6IE5MIGlzIHJldHVybmVkXG4gICAgICogaW5zdGVhZC5cbiAgICAgKi9cbiAgICBjYXB0dXJlTmFtZUNoYXJzKCkge1xuICAgICAgICBjb25zdCB7IGNodW5rLCBpOiBzdGFydCB9ID0gdGhpcztcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnN0YW50LWNvbmRpdGlvblxuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgY29uc3QgYyA9IHRoaXMuZ2V0Q29kZSgpO1xuICAgICAgICAgICAgaWYgKGMgPT09IEVPQykge1xuICAgICAgICAgICAgICAgIHRoaXMubmFtZSArPSBjaHVuay5zbGljZShzdGFydCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEVPQztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE5MIGlzIG5vdCBhIG5hbWUgY2hhciBzbyB3ZSBkb24ndCBoYXZlIHRvIHRlc3Qgc3BlY2lmaWNhbGx5IGZvciBpdC5cbiAgICAgICAgICAgIGlmICghaXNOYW1lQ2hhcihjKSkge1xuICAgICAgICAgICAgICAgIHRoaXMubmFtZSArPSBjaHVuay5zbGljZShzdGFydCwgdGhpcy5wcmV2SSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGMgPT09IE5MX0xJS0UgPyBOTCA6IGM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2tpcCB3aGl0ZSBzcGFjZXMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIFRoZSBjaGFyYWN0ZXIgdGhhdCBlbmRlZCB0aGUgc2tpcCwgb3IgYGBFT0NgYCBpZiB3ZSBoaXRcbiAgICAgKiB0aGUgZW5kIG9mIHRoZSBjaHVuay4gVGhlIHJldHVybiB2YWx1ZSBjYW5ub3QgYmUgTkxfTElLRTogTkwgaXMgcmV0dXJuZWRcbiAgICAgKiBpbnN0ZWFkLlxuICAgICAqL1xuICAgIHNraXBTcGFjZXMoKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zdGFudC1jb25kaXRpb25cbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIGNvbnN0IGMgPSB0aGlzLmdldENvZGVOb3JtKCk7XG4gICAgICAgICAgICBpZiAoYyA9PT0gRU9DIHx8ICFpc1MoYykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXRYTUxWZXJzaW9uKHZlcnNpb24pIHtcbiAgICAgICAgdGhpcy5jdXJyZW50WE1MVmVyc2lvbiA9IHZlcnNpb247XG4gICAgICAgIC8qICBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvdW5ib3VuZC1tZXRob2QgKi9cbiAgICAgICAgaWYgKHZlcnNpb24gPT09IFwiMS4wXCIpIHtcbiAgICAgICAgICAgIHRoaXMuaXNDaGFyID0gaXNDaGFyMTA7XG4gICAgICAgICAgICB0aGlzLmdldENvZGUgPSB0aGlzLmdldENvZGUxMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaXNDaGFyID0gaXNDaGFyMTE7XG4gICAgICAgICAgICB0aGlzLmdldENvZGUgPSB0aGlzLmdldENvZGUxMTtcbiAgICAgICAgfVxuICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIEB0eXBlc2NyaXB0LWVzbGludC91bmJvdW5kLW1ldGhvZCAqL1xuICAgIH1cbiAgICAvLyBTVEFURSBFTkdJTkUgTUVUSE9EU1xuICAgIC8vIFRoaXMgbmVlZHMgdG8gYmUgYSBzdGF0ZSBzZXBhcmF0ZSBmcm9tIFNfQkVHSU5fV0hJVEVTUEFDRSBiZWNhdXNlIHdlIHdhbnRcbiAgICAvLyB0byBiZSBzdXJlIG5ldmVyIHRvIGNvbWUgYmFjayB0byB0aGlzIHN0YXRlIGxhdGVyLlxuICAgIHNCZWdpbigpIHtcbiAgICAgICAgLy8gV2UgYXJlIGVzc2VudGlhbGx5IHBlZWtpbmcgYXQgdGhlIGZpcnN0IGNoYXJhY3RlciBvZiB0aGUgY2h1bmsuIFNpbmNlXG4gICAgICAgIC8vIFNfQkVHSU4gY2FuIGJlIGluIGVmZmVjdCBvbmx5IHdoZW4gd2Ugc3RhcnQgd29ya2luZyBvbiB0aGUgZmlyc3QgY2h1bmssXG4gICAgICAgIC8vIHRoZSBpbmRleCBhdCB3aGljaCB3ZSBtdXN0IGxvb2sgaXMgbmVjZXNzYXJpbHkgMC4gTm90ZSBhbHNvIHRoYXQgdGhlXG4gICAgICAgIC8vIGZvbGxvd2luZyB0ZXN0IGRvZXMgbm90IGRlcGVuZCBvbiBkZWNvZGluZyBzdXJyb2dhdGVzLlxuICAgICAgICAvLyBJZiB0aGUgaW5pdGlhbCBjaGFyYWN0ZXIgaXMgMHhGRUZGLCBpZ25vcmUgaXQuXG4gICAgICAgIGlmICh0aGlzLmNodW5rLmNoYXJDb2RlQXQoMCkgPT09IDB4RkVGRikge1xuICAgICAgICAgICAgdGhpcy5pKys7XG4gICAgICAgICAgICB0aGlzLmNvbHVtbisrO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhdGUgPSBTX0JFR0lOX1dISVRFU1BBQ0U7XG4gICAgfVxuICAgIHNCZWdpbldoaXRlc3BhY2UoKSB7XG4gICAgICAgIC8vIFdlIG5lZWQgdG8ga25vdyB3aGV0aGVyIHdlJ3ZlIGVuY291bnRlcmVkIHNwYWNlcyBvciBub3QgYmVjYXVzZSBhcyBzb29uXG4gICAgICAgIC8vIGFzIHdlIHJ1biBpbnRvIGEgc3BhY2UsIGFuIFhNTCBkZWNsYXJhdGlvbiBpcyBubyBsb25nZXIgcG9zc2libGUuIFJhdGhlclxuICAgICAgICAvLyB0aGFuIHNsb3cgZG93biBza2lwU3BhY2VzIGV2ZW4gaW4gcGxhY2VzIHdoZXJlIHdlIGRvbid0IGNhcmUgd2hldGhlciBpdFxuICAgICAgICAvLyBza2lwcGVkIGFueXRoaW5nIG9yIG5vdCwgd2UgY2hlY2sgd2hldGhlciBwcmV2SSBpcyBlcXVhbCB0byB0aGUgdmFsdWUgb2ZcbiAgICAgICAgLy8gaSBmcm9tIGJlZm9yZSB3ZSBza2lwIHNwYWNlcy5cbiAgICAgICAgY29uc3QgaUJlZm9yZSA9IHRoaXMuaTtcbiAgICAgICAgY29uc3QgYyA9IHRoaXMuc2tpcFNwYWNlcygpO1xuICAgICAgICBpZiAodGhpcy5wcmV2SSAhPT0gaUJlZm9yZSkge1xuICAgICAgICAgICAgdGhpcy54bWxEZWNsUG9zc2libGUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKGMpIHtcbiAgICAgICAgICAgIGNhc2UgTEVTUzpcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gU19PUEVOX1dBS0E7XG4gICAgICAgICAgICAgICAgLy8gV2UgY291bGQgbmFpdmVseSBjYWxsIGNsb3NlVGV4dCBidXQgaW4gdGhpcyBzdGF0ZSwgaXQgaXMgbm90IG5vcm1hbFxuICAgICAgICAgICAgICAgIC8vIHRvIGhhdmUgdGV4dCBiZSBmaWxsZWQgd2l0aCBhbnkgZGF0YS5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy50ZXh0Lmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJuby1lbXB0eSB0ZXh0IGF0IHN0YXJ0XCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgRU9DOlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aGlzLnVuZ2V0KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFNfVEVYVDtcbiAgICAgICAgICAgICAgICB0aGlzLnhtbERlY2xQb3NzaWJsZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNEb2N0eXBlKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IGMgPSB0aGlzLmNhcHR1cmVUbyhET0NUWVBFX1RFUk1JTkFUT1IpO1xuICAgICAgICBzd2l0Y2ggKGMpIHtcbiAgICAgICAgICAgIGNhc2UgR1JFQVRFUjoge1xuICAgICAgICAgICAgICAgIChfYSA9IHRoaXMuZG9jdHlwZUhhbmRsZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHRoaXMsIHRoaXMudGV4dCk7XG4gICAgICAgICAgICAgICAgdGhpcy50ZXh0ID0gXCJcIjtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gU19URVhUO1xuICAgICAgICAgICAgICAgIHRoaXMuZG9jdHlwZSA9IHRydWU7IC8vIGp1c3QgcmVtZW1iZXIgdGhhdCB3ZSBzYXcgaXQuXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIEVPQzpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhpcy50ZXh0ICs9IFN0cmluZy5mcm9tQ29kZVBvaW50KGMpO1xuICAgICAgICAgICAgICAgIGlmIChjID09PSBPUEVOX0JSQUNLRVQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFNfRFREO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpc1F1b3RlKGMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTX0RPQ1RZUEVfUVVPVEU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucSA9IGM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHNEb2N0eXBlUXVvdGUoKSB7XG4gICAgICAgIGNvbnN0IHEgPSB0aGlzLnE7XG4gICAgICAgIGlmICh0aGlzLmNhcHR1cmVUb0NoYXIocSkpIHtcbiAgICAgICAgICAgIHRoaXMudGV4dCArPSBTdHJpbmcuZnJvbUNvZGVQb2ludChxKTtcbiAgICAgICAgICAgIHRoaXMucSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU19ET0NUWVBFO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNEVEQoKSB7XG4gICAgICAgIGNvbnN0IGMgPSB0aGlzLmNhcHR1cmVUbyhEVERfVEVSTUlOQVRPUik7XG4gICAgICAgIGlmIChjID09PSBFT0MpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRleHQgKz0gU3RyaW5nLmZyb21Db2RlUG9pbnQoYyk7XG4gICAgICAgIGlmIChjID09PSBDTE9TRV9CUkFDS0VUKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU19ET0NUWVBFO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGMgPT09IExFU1MpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTX0RURF9PUEVOX1dBS0E7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNRdW90ZShjKSkge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFNfRFREX1FVT1RFRDtcbiAgICAgICAgICAgIHRoaXMucSA9IGM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc0RURFF1b3RlZCgpIHtcbiAgICAgICAgY29uc3QgcSA9IHRoaXMucTtcbiAgICAgICAgaWYgKHRoaXMuY2FwdHVyZVRvQ2hhcihxKSkge1xuICAgICAgICAgICAgdGhpcy50ZXh0ICs9IFN0cmluZy5mcm9tQ29kZVBvaW50KHEpO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFNfRFREO1xuICAgICAgICAgICAgdGhpcy5xID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzRFRET3Blbldha2EoKSB7XG4gICAgICAgIGNvbnN0IGMgPSB0aGlzLmdldENvZGVOb3JtKCk7XG4gICAgICAgIHRoaXMudGV4dCArPSBTdHJpbmcuZnJvbUNvZGVQb2ludChjKTtcbiAgICAgICAgc3dpdGNoIChjKSB7XG4gICAgICAgICAgICBjYXNlIEJBTkc6XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFNfRFREX09QRU5fV0FLQV9CQU5HO1xuICAgICAgICAgICAgICAgIHRoaXMub3Blbldha2FCYW5nID0gXCJcIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgUVVFU1RJT046XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFNfRFREX1BJO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gU19EVEQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc0RURE9wZW5XYWthQmFuZygpIHtcbiAgICAgICAgY29uc3QgY2hhciA9IFN0cmluZy5mcm9tQ29kZVBvaW50KHRoaXMuZ2V0Q29kZU5vcm0oKSk7XG4gICAgICAgIGNvbnN0IG93YiA9IHRoaXMub3Blbldha2FCYW5nICs9IGNoYXI7XG4gICAgICAgIHRoaXMudGV4dCArPSBjaGFyO1xuICAgICAgICBpZiAob3diICE9PSBcIi1cIikge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IG93YiA9PT0gXCItLVwiID8gU19EVERfQ09NTUVOVCA6IFNfRFREO1xuICAgICAgICAgICAgdGhpcy5vcGVuV2FrYUJhbmcgPSBcIlwiO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNEVERDb21tZW50KCkge1xuICAgICAgICBpZiAodGhpcy5jYXB0dXJlVG9DaGFyKE1JTlVTKSkge1xuICAgICAgICAgICAgdGhpcy50ZXh0ICs9IFwiLVwiO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFNfRFREX0NPTU1FTlRfRU5ESU5HO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNEVERDb21tZW50RW5kaW5nKCkge1xuICAgICAgICBjb25zdCBjID0gdGhpcy5nZXRDb2RlTm9ybSgpO1xuICAgICAgICB0aGlzLnRleHQgKz0gU3RyaW5nLmZyb21Db2RlUG9pbnQoYyk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBjID09PSBNSU5VUyA/IFNfRFREX0NPTU1FTlRfRU5ERUQgOiBTX0RURF9DT01NRU5UO1xuICAgIH1cbiAgICBzRFREQ29tbWVudEVuZGVkKCkge1xuICAgICAgICBjb25zdCBjID0gdGhpcy5nZXRDb2RlTm9ybSgpO1xuICAgICAgICB0aGlzLnRleHQgKz0gU3RyaW5nLmZyb21Db2RlUG9pbnQoYyk7XG4gICAgICAgIGlmIChjID09PSBHUkVBVEVSKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU19EVEQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmZhaWwoXCJtYWxmb3JtZWQgY29tbWVudC5cIik7XG4gICAgICAgICAgICAvLyA8IS0tIGJsYWggLS0gYmxvbyAtLT4gd2lsbCBiZSByZWNvcmRlZCBhc1xuICAgICAgICAgICAgLy8gYSBjb21tZW50IG9mIFwiIGJsYWggLS0gYmxvbyBcIlxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFNfRFREX0NPTU1FTlQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc0RURFBJKCkge1xuICAgICAgICBpZiAodGhpcy5jYXB0dXJlVG9DaGFyKFFVRVNUSU9OKSkge1xuICAgICAgICAgICAgdGhpcy50ZXh0ICs9IFwiP1wiO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFNfRFREX1BJX0VORElORztcbiAgICAgICAgfVxuICAgIH1cbiAgICBzRFREUElFbmRpbmcoKSB7XG4gICAgICAgIGNvbnN0IGMgPSB0aGlzLmdldENvZGVOb3JtKCk7XG4gICAgICAgIHRoaXMudGV4dCArPSBTdHJpbmcuZnJvbUNvZGVQb2ludChjKTtcbiAgICAgICAgaWYgKGMgPT09IEdSRUFURVIpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTX0RURDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzVGV4dCgpIHtcbiAgICAgICAgLy9cbiAgICAgICAgLy8gV2UgZGlkIHRyeSBhIHZlcnNpb24gb2Ygc2F4ZXMgd2hlcmUgdGhlIFNfVEVYVCBzdGF0ZSB3YXMgc3BsaXQgaW4gdHdvXG4gICAgICAgIC8vIHN0YXRlczogb25lIGZvciB0ZXh0IGluc2lkZSB0aGUgcm9vdCBlbGVtZW50LCBhbmQgb25lIGZvciB0ZXh0XG4gICAgICAgIC8vIG91dHNpZGUuIFRoaXMgd2FzIGF2b2lkaW5nIGhhdmluZyB0byB0ZXN0IHRoaXMudGFncy5sZW5ndGggdG8gZGVjaWRlXG4gICAgICAgIC8vIHdoYXQgaW1wbGVtZW50YXRpb24gdG8gYWN0dWFsbHkgdXNlLlxuICAgICAgICAvL1xuICAgICAgICAvLyBQZWZvcm1hbmNlIHRlc3Rpbmcgb24gZ2lnYWJ5dGUtc2l6ZSBmaWxlcyBkaWQgbm90IHNob3cgYW55IGFkdmFudGFnZSB0b1xuICAgICAgICAvLyB1c2luZyB0aGUgdHdvIHN0YXRlcyBzb2x1dGlvbiBpbnN0ZWFkIG9mIHRoZSBjdXJyZW50IG9uZS4gQ29udmVyc2VseSwgaXRcbiAgICAgICAgLy8gbWFkZSB0aGUgY29kZSBhIGJpdCBtb3JlIGNvbXBsaWNhdGVkIGVsc2V3aGVyZS4gRm9yIGluc3RhbmNlLCBhIGNvbW1lbnRcbiAgICAgICAgLy8gY2FuIGFwcGVhciBiZWZvcmUgdGhlIHJvb3QgZWxlbWVudCBzbyB3aGVuIGEgY29tbWVudCBlbmRlZCBpdCB3YXNcbiAgICAgICAgLy8gbmVjZXNzYXJ5IHRvIGRldGVybWluZSB3aGV0aGVyIHRvIHJldHVybiB0byB0aGUgU19URVhUIHN0YXRlIG9yIHRvIHRoZVxuICAgICAgICAvLyBuZXcgdGV4dC1vdXRzaWRlLXJvb3Qgc3RhdGUuXG4gICAgICAgIC8vXG4gICAgICAgIGlmICh0aGlzLnRhZ3MubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZVRleHRJblJvb3QoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlVGV4dE91dHNpZGVSb290KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc0VudGl0eSgpIHtcbiAgICAgICAgLy8gVGhpcyBpcyBlc3NlbnRpYWxseSBhIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgY2FwdHVyZVRvQ2hhcihTRU1JQ09MT04uLi4pXG4gICAgICAgIGxldCB7IGk6IHN0YXJ0IH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB7IGNodW5rIH0gPSB0aGlzO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbGFiZWxzLCBuby1yZXN0cmljdGVkLXN5bnRheFxuICAgICAgICBsb29wOiBcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnN0YW50LWNvbmRpdGlvblxuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgc3dpdGNoICh0aGlzLmdldENvZGUoKSkge1xuICAgICAgICAgICAgICAgIGNhc2UgTkxfTElLRTpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbnRpdHkgKz0gYCR7Y2h1bmsuc2xpY2Uoc3RhcnQsIHRoaXMucHJldkkpfVxcbmA7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gdGhpcy5pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFNFTUlDT0xPTjoge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGVudGl0eVJldHVyblN0YXRlIH0gPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlbnRpdHkgPSB0aGlzLmVudGl0eSArIGNodW5rLnNsaWNlKHN0YXJ0LCB0aGlzLnByZXZJKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IGVudGl0eVJldHVyblN0YXRlO1xuICAgICAgICAgICAgICAgICAgICBsZXQgcGFyc2VkO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZW50aXR5ID09PSBcIlwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZhaWwoXCJlbXB0eSBlbnRpdHkgbmFtZS5cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZWQgPSBcIiY7XCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZWQgPSB0aGlzLnBhcnNlRW50aXR5KGVudGl0eSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVudGl0eSA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGVudGl0eVJldHVyblN0YXRlICE9PSBTX1RFWFQgfHwgdGhpcy50ZXh0SGFuZGxlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRleHQgKz0gcGFyc2VkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1sYWJlbHNcbiAgICAgICAgICAgICAgICAgICAgYnJlYWsgbG9vcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSBFT0M6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW50aXR5ICs9IGNodW5rLnNsaWNlKHN0YXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWxhYmVsc1xuICAgICAgICAgICAgICAgICAgICBicmVhayBsb29wO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgc09wZW5XYWthKCkge1xuICAgICAgICAvLyBSZW1pbmRlcjogYSBzdGF0ZSBoYW5kbGVyIGlzIGNhbGxlZCB3aXRoIGF0IGxlYXN0IG9uZSBjaGFyYWN0ZXJcbiAgICAgICAgLy8gYXZhaWxhYmxlIGluIHRoZSBjdXJyZW50IGNodW5rLiBTbyB0aGUgZmlyc3QgY2FsbCB0byBnZXQgY29kZSBpbnNpZGUgb2ZcbiAgICAgICAgLy8gYSBzdGF0ZSBoYW5kbGVyIGNhbm5vdCByZXR1cm4gYGBFT0NgYC4gVGhhdCdzIHdoeSB3ZSBkb24ndCB0ZXN0XG4gICAgICAgIC8vIGZvciBpdC5cbiAgICAgICAgY29uc3QgYyA9IHRoaXMuZ2V0Q29kZSgpO1xuICAgICAgICAvLyBlaXRoZXIgYSAvLCA/LCAhLCBvciB0ZXh0IGlzIGNvbWluZyBuZXh0LlxuICAgICAgICBpZiAoaXNOYW1lU3RhcnRDaGFyKGMpKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU19PUEVOX1RBRztcbiAgICAgICAgICAgIHRoaXMudW5nZXQoKTtcbiAgICAgICAgICAgIHRoaXMueG1sRGVjbFBvc3NpYmxlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIEZPUldBUkRfU0xBU0g6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTX0NMT1NFX1RBRztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy54bWxEZWNsUG9zc2libGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBCQU5HOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gU19PUEVOX1dBS0FfQkFORztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vcGVuV2FrYUJhbmcgPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnhtbERlY2xQb3NzaWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFFVRVNUSU9OOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gU19QSV9GSVJTVF9DSEFSO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmZhaWwoXCJkaXNhbGxvd2VkIGNoYXJhY3RlciBpbiB0YWcgbmFtZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFNfVEVYVDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy54bWxEZWNsUG9zc2libGUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBzT3Blbldha2FCYW5nKCkge1xuICAgICAgICB0aGlzLm9wZW5XYWthQmFuZyArPSBTdHJpbmcuZnJvbUNvZGVQb2ludCh0aGlzLmdldENvZGVOb3JtKCkpO1xuICAgICAgICBzd2l0Y2ggKHRoaXMub3Blbldha2FCYW5nKSB7XG4gICAgICAgICAgICBjYXNlIFwiW0NEQVRBW1wiOlxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5zYXdSb290ICYmICF0aGlzLnJlcG9ydGVkVGV4dEJlZm9yZVJvb3QpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mYWlsKFwidGV4dCBkYXRhIG91dHNpZGUgb2Ygcm9vdCBub2RlLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXBvcnRlZFRleHRCZWZvcmVSb290ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY2xvc2VkUm9vdCAmJiAhdGhpcy5yZXBvcnRlZFRleHRBZnRlclJvb3QpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mYWlsKFwidGV4dCBkYXRhIG91dHNpZGUgb2Ygcm9vdCBub2RlLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXBvcnRlZFRleHRBZnRlclJvb3QgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gU19DREFUQTtcbiAgICAgICAgICAgICAgICB0aGlzLm9wZW5XYWthQmFuZyA9IFwiXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiLS1cIjpcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gU19DT01NRU5UO1xuICAgICAgICAgICAgICAgIHRoaXMub3Blbldha2FCYW5nID0gXCJcIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJET0NUWVBFXCI6XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFNfRE9DVFlQRTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5kb2N0eXBlIHx8IHRoaXMuc2F3Um9vdCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZhaWwoXCJpbmFwcHJvcHJpYXRlbHkgbG9jYXRlZCBkb2N0eXBlIGRlY2xhcmF0aW9uLlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5vcGVuV2FrYUJhbmcgPSBcIlwiO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAvLyA3IGhhcHBlbnMgdG8gYmUgdGhlIG1heGltdW0gbGVuZ3RoIG9mIHRoZSBzdHJpbmcgdGhhdCBjYW4gcG9zc2libHlcbiAgICAgICAgICAgICAgICAvLyBtYXRjaCBvbmUgb2YgdGhlIGNhc2VzIGFib3ZlLlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wZW5XYWthQmFuZy5sZW5ndGggPj0gNykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZhaWwoXCJpbmNvcnJlY3Qgc3ludGF4LlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgc0NvbW1lbnQoKSB7XG4gICAgICAgIGlmICh0aGlzLmNhcHR1cmVUb0NoYXIoTUlOVVMpKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU19DT01NRU5UX0VORElORztcbiAgICAgICAgfVxuICAgIH1cbiAgICBzQ29tbWVudEVuZGluZygpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBjID0gdGhpcy5nZXRDb2RlTm9ybSgpO1xuICAgICAgICBpZiAoYyA9PT0gTUlOVVMpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTX0NPTU1FTlRfRU5ERUQ7XG4gICAgICAgICAgICAoX2EgPSB0aGlzLmNvbW1lbnRIYW5kbGVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh0aGlzLCB0aGlzLnRleHQpO1xuICAgICAgICAgICAgdGhpcy50ZXh0ID0gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudGV4dCArPSBgLSR7U3RyaW5nLmZyb21Db2RlUG9pbnQoYyl9YDtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTX0NPTU1FTlQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc0NvbW1lbnRFbmRlZCgpIHtcbiAgICAgICAgY29uc3QgYyA9IHRoaXMuZ2V0Q29kZU5vcm0oKTtcbiAgICAgICAgaWYgKGMgIT09IEdSRUFURVIpIHtcbiAgICAgICAgICAgIHRoaXMuZmFpbChcIm1hbGZvcm1lZCBjb21tZW50LlwiKTtcbiAgICAgICAgICAgIC8vIDwhLS0gYmxhaCAtLSBibG9vIC0tPiB3aWxsIGJlIHJlY29yZGVkIGFzXG4gICAgICAgICAgICAvLyBhIGNvbW1lbnQgb2YgXCIgYmxhaCAtLSBibG9vIFwiXG4gICAgICAgICAgICB0aGlzLnRleHQgKz0gYC0tJHtTdHJpbmcuZnJvbUNvZGVQb2ludChjKX1gO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFNfQ09NTUVOVDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTX1RFWFQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc0NEYXRhKCkge1xuICAgICAgICBpZiAodGhpcy5jYXB0dXJlVG9DaGFyKENMT1NFX0JSQUNLRVQpKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU19DREFUQV9FTkRJTkc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc0NEYXRhRW5kaW5nKCkge1xuICAgICAgICBjb25zdCBjID0gdGhpcy5nZXRDb2RlTm9ybSgpO1xuICAgICAgICBpZiAoYyA9PT0gQ0xPU0VfQlJBQ0tFVCkge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFNfQ0RBVEFfRU5ESU5HXzI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnRleHQgKz0gYF0ke1N0cmluZy5mcm9tQ29kZVBvaW50KGMpfWA7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU19DREFUQTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzQ0RhdGFFbmRpbmcyKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IGMgPSB0aGlzLmdldENvZGVOb3JtKCk7XG4gICAgICAgIHN3aXRjaCAoYykge1xuICAgICAgICAgICAgY2FzZSBHUkVBVEVSOiB7XG4gICAgICAgICAgICAgICAgKF9hID0gdGhpcy5jZGF0YUhhbmRsZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHRoaXMsIHRoaXMudGV4dCk7XG4gICAgICAgICAgICAgICAgdGhpcy50ZXh0ID0gXCJcIjtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gU19URVhUO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBDTE9TRV9CUkFDS0VUOlxuICAgICAgICAgICAgICAgIHRoaXMudGV4dCArPSBcIl1cIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhpcy50ZXh0ICs9IGBdXSR7U3RyaW5nLmZyb21Db2RlUG9pbnQoYyl9YDtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gU19DREFUQTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBXZSBuZWVkIHRoaXMgc2VwYXJhdGUgc3RhdGUgdG8gY2hlY2sgdGhlIGZpcnN0IGNoYXJhY3RlciBmbyB0aGUgcGkgdGFyZ2V0XG4gICAgLy8gd2l0aCB0aGlzLm5hbWVTdGFydENoZWNrIHdoaWNoIGFsbG93cyBsZXNzIGNoYXJhY3RlcnMgdGhhbiB0aGlzLm5hbWVDaGVjay5cbiAgICBzUElGaXJzdENoYXIoKSB7XG4gICAgICAgIGNvbnN0IGMgPSB0aGlzLmdldENvZGVOb3JtKCk7XG4gICAgICAgIC8vIFRoaXMgaXMgZmlyc3QgYmVjYXVzZSBpbiB0aGUgY2FzZSB3aGVyZSB0aGUgZmlsZSBpcyB3ZWxsLWZvcm1lZCB0aGlzIGlzXG4gICAgICAgIC8vIHRoZSBicmFuY2ggdGFrZW4uIFdlIG9wdGltaXplIGZvciB3ZWxsLWZvcm1lZG5lc3MuXG4gICAgICAgIGlmICh0aGlzLm5hbWVTdGFydENoZWNrKGMpKSB7XG4gICAgICAgICAgICB0aGlzLnBpVGFyZ2V0ICs9IFN0cmluZy5mcm9tQ29kZVBvaW50KGMpO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFNfUElfUkVTVDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjID09PSBRVUVTVElPTiB8fCBpc1MoYykpIHtcbiAgICAgICAgICAgIHRoaXMuZmFpbChcInByb2Nlc3NpbmcgaW5zdHJ1Y3Rpb24gd2l0aG91dCBhIHRhcmdldC5cIik7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gYyA9PT0gUVVFU1RJT04gPyBTX1BJX0VORElORyA6IFNfUElfQk9EWTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZmFpbChcImRpc2FsbG93ZWQgY2hhcmFjdGVyIGluIHByb2Nlc3NpbmcgaW5zdHJ1Y3Rpb24gbmFtZS5cIik7XG4gICAgICAgICAgICB0aGlzLnBpVGFyZ2V0ICs9IFN0cmluZy5mcm9tQ29kZVBvaW50KGMpO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFNfUElfUkVTVDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzUElSZXN0KCkge1xuICAgICAgICAvLyBDYXB0dXJlIGNoYXJhY3RlcnMgaW50byBhIHBpVGFyZ2V0IHdoaWxlIGBgdGhpcy5uYW1lQ2hlY2tgYCBydW4gb24gdGhlXG4gICAgICAgIC8vIGNoYXJhY3RlciByZWFkIHJldHVybnMgdHJ1ZS5cbiAgICAgICAgY29uc3QgeyBjaHVuaywgaTogc3RhcnQgfSA9IHRoaXM7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zdGFudC1jb25kaXRpb25cbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIGNvbnN0IGMgPSB0aGlzLmdldENvZGVOb3JtKCk7XG4gICAgICAgICAgICBpZiAoYyA9PT0gRU9DKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5waVRhcmdldCArPSBjaHVuay5zbGljZShzdGFydCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTkwgY2Fubm90IHNhdGlzZnkgdGhpcy5uYW1lQ2hlY2sgc28gd2UgZG9uJ3QgaGF2ZSB0byB0ZXN0IHNwZWNpZmljYWxseVxuICAgICAgICAgICAgLy8gZm9yIGl0LlxuICAgICAgICAgICAgaWYgKCF0aGlzLm5hbWVDaGVjayhjKSkge1xuICAgICAgICAgICAgICAgIHRoaXMucGlUYXJnZXQgKz0gY2h1bmsuc2xpY2Uoc3RhcnQsIHRoaXMucHJldkkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzUXVlc3Rpb24gPSBjID09PSBRVUVTVElPTjtcbiAgICAgICAgICAgICAgICBpZiAoaXNRdWVzdGlvbiB8fCBpc1MoYykpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucGlUYXJnZXQgPT09IFwieG1sXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy54bWxEZWNsUG9zc2libGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZhaWwoXCJhbiBYTUwgZGVjbGFyYXRpb24gbXVzdCBiZSBhdCB0aGUgc3RhcnQgb2YgdGhlIGRvY3VtZW50LlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBpc1F1ZXN0aW9uID8gU19YTUxfREVDTF9FTkRJTkcgOiBTX1hNTF9ERUNMX05BTUVfU1RBUlQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gaXNRdWVzdGlvbiA/IFNfUElfRU5ESU5HIDogU19QSV9CT0RZO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZhaWwoXCJkaXNhbGxvd2VkIGNoYXJhY3RlciBpbiBwcm9jZXNzaW5nIGluc3RydWN0aW9uIG5hbWUuXCIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBpVGFyZ2V0ICs9IFN0cmluZy5mcm9tQ29kZVBvaW50KGMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBzUElCb2R5KCkge1xuICAgICAgICBpZiAodGhpcy50ZXh0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgY29uc3QgYyA9IHRoaXMuZ2V0Q29kZU5vcm0oKTtcbiAgICAgICAgICAgIGlmIChjID09PSBRVUVTVElPTikge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTX1BJX0VORElORztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFpc1MoYykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRleHQgPSBTdHJpbmcuZnJvbUNvZGVQb2ludChjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBUaGUgcXVlc3Rpb24gbWFyayBjaGFyYWN0ZXIgaXMgbm90IHZhbGlkIGluc2lkZSBhbnkgb2YgdGhlIFhNTFxuICAgICAgICAvLyBkZWNsYXJhdGlvbiBuYW1lL3ZhbHVlIHBhaXJzLlxuICAgICAgICBlbHNlIGlmICh0aGlzLmNhcHR1cmVUb0NoYXIoUVVFU1RJT04pKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU19QSV9FTkRJTkc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc1BJRW5kaW5nKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IGMgPSB0aGlzLmdldENvZGVOb3JtKCk7XG4gICAgICAgIGlmIChjID09PSBHUkVBVEVSKSB7XG4gICAgICAgICAgICBjb25zdCB7IHBpVGFyZ2V0IH0gPSB0aGlzO1xuICAgICAgICAgICAgaWYgKHBpVGFyZ2V0LnRvTG93ZXJDYXNlKCkgPT09IFwieG1sXCIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZhaWwoXCJ0aGUgWE1MIGRlY2xhcmF0aW9uIG11c3QgYXBwZWFyIGF0IHRoZSBzdGFydCBvZiB0aGUgZG9jdW1lbnQuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKF9hID0gdGhpcy5waUhhbmRsZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHRoaXMsIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IHBpVGFyZ2V0LFxuICAgICAgICAgICAgICAgIGJvZHk6IHRoaXMudGV4dCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5waVRhcmdldCA9IHRoaXMudGV4dCA9IFwiXCI7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU19URVhUO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGMgPT09IFFVRVNUSU9OKSB7XG4gICAgICAgICAgICAvLyBXZSByYW4gaW50byA/PyBhcyBwYXJ0IG9mIGEgcHJvY2Vzc2luZyBpbnN0cnVjdGlvbi4gV2UgaW5pdGlhbGx5IHRvb2tcbiAgICAgICAgICAgIC8vIHRoZSBmaXJzdCA/IGFzIGEgc2lnbiB0aGF0IHRoZSBQSSB3YXMgZW5kaW5nLCBidXQgaXQgaXMgbm90LiBTbyB3ZSBoYXZlXG4gICAgICAgICAgICAvLyB0byBhZGQgaXQgdG8gdGhlIGJvZHkgYnV0IHdlIHRha2UgdGhlIG5ldyA/IGFzIGEgc2lnbiB0aGF0IHRoZSBQSSBpc1xuICAgICAgICAgICAgLy8gZW5kaW5nLlxuICAgICAgICAgICAgdGhpcy50ZXh0ICs9IFwiP1wiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy50ZXh0ICs9IGA/JHtTdHJpbmcuZnJvbUNvZGVQb2ludChjKX1gO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFNfUElfQk9EWTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnhtbERlY2xQb3NzaWJsZSA9IGZhbHNlO1xuICAgIH1cbiAgICBzWE1MRGVjbE5hbWVTdGFydCgpIHtcbiAgICAgICAgY29uc3QgYyA9IHRoaXMuc2tpcFNwYWNlcygpO1xuICAgICAgICAvLyBUaGUgcXVlc3Rpb24gbWFyayBjaGFyYWN0ZXIgaXMgbm90IHZhbGlkIGluc2lkZSBhbnkgb2YgdGhlIFhNTFxuICAgICAgICAvLyBkZWNsYXJhdGlvbiBuYW1lL3ZhbHVlIHBhaXJzLlxuICAgICAgICBpZiAoYyA9PT0gUVVFU1RJT04pIHtcbiAgICAgICAgICAgIC8vIEl0IGlzIHZhbGlkIHRvIGdvIHRvIFNfWE1MX0RFQ0xfRU5ESU5HIGZyb20gdGhpcyBzdGF0ZS5cbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTX1hNTF9ERUNMX0VORElORztcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYyAhPT0gRU9DKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU19YTUxfREVDTF9OQU1FO1xuICAgICAgICAgICAgdGhpcy5uYW1lID0gU3RyaW5nLmZyb21Db2RlUG9pbnQoYyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc1hNTERlY2xOYW1lKCkge1xuICAgICAgICBjb25zdCBjID0gdGhpcy5jYXB0dXJlVG8oWE1MX0RFQ0xfTkFNRV9URVJNSU5BVE9SKTtcbiAgICAgICAgLy8gVGhlIHF1ZXN0aW9uIG1hcmsgY2hhcmFjdGVyIGlzIG5vdCB2YWxpZCBpbnNpZGUgYW55IG9mIHRoZSBYTUxcbiAgICAgICAgLy8gZGVjbGFyYXRpb24gbmFtZS92YWx1ZSBwYWlycy5cbiAgICAgICAgaWYgKGMgPT09IFFVRVNUSU9OKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU19YTUxfREVDTF9FTkRJTkc7XG4gICAgICAgICAgICB0aGlzLm5hbWUgKz0gdGhpcy50ZXh0O1xuICAgICAgICAgICAgdGhpcy50ZXh0ID0gXCJcIjtcbiAgICAgICAgICAgIHRoaXMuZmFpbChcIlhNTCBkZWNsYXJhdGlvbiBpcyBpbmNvbXBsZXRlLlwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIShpc1MoYykgfHwgYyA9PT0gRVFVQUwpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5uYW1lICs9IHRoaXMudGV4dDtcbiAgICAgICAgdGhpcy50ZXh0ID0gXCJcIjtcbiAgICAgICAgaWYgKCF0aGlzLnhtbERlY2xFeHBlY3RzLmluY2x1ZGVzKHRoaXMubmFtZSkpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5uYW1lLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mYWlsKFwiZGlkIG5vdCBleHBlY3QgYW55IG1vcmUgbmFtZS92YWx1ZSBwYWlycy5cIik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mYWlsKGBleHBlY3RlZCB0aGUgbmFtZSAke3RoaXMueG1sRGVjbEV4cGVjdHNbMF19LmApO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmZhaWwoYGV4cGVjdGVkIG9uZSBvZiAke3RoaXMueG1sRGVjbEV4cGVjdHMuam9pbihcIiwgXCIpfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhdGUgPSBjID09PSBFUVVBTCA/IFNfWE1MX0RFQ0xfVkFMVUVfU1RBUlQgOiBTX1hNTF9ERUNMX0VRO1xuICAgIH1cbiAgICBzWE1MRGVjbEVxKCkge1xuICAgICAgICBjb25zdCBjID0gdGhpcy5nZXRDb2RlTm9ybSgpO1xuICAgICAgICAvLyBUaGUgcXVlc3Rpb24gbWFyayBjaGFyYWN0ZXIgaXMgbm90IHZhbGlkIGluc2lkZSBhbnkgb2YgdGhlIFhNTFxuICAgICAgICAvLyBkZWNsYXJhdGlvbiBuYW1lL3ZhbHVlIHBhaXJzLlxuICAgICAgICBpZiAoYyA9PT0gUVVFU1RJT04pIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTX1hNTF9ERUNMX0VORElORztcbiAgICAgICAgICAgIHRoaXMuZmFpbChcIlhNTCBkZWNsYXJhdGlvbiBpcyBpbmNvbXBsZXRlLlwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNTKGMpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGMgIT09IEVRVUFMKSB7XG4gICAgICAgICAgICB0aGlzLmZhaWwoXCJ2YWx1ZSByZXF1aXJlZC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGF0ZSA9IFNfWE1MX0RFQ0xfVkFMVUVfU1RBUlQ7XG4gICAgfVxuICAgIHNYTUxEZWNsVmFsdWVTdGFydCgpIHtcbiAgICAgICAgY29uc3QgYyA9IHRoaXMuZ2V0Q29kZU5vcm0oKTtcbiAgICAgICAgLy8gVGhlIHF1ZXN0aW9uIG1hcmsgY2hhcmFjdGVyIGlzIG5vdCB2YWxpZCBpbnNpZGUgYW55IG9mIHRoZSBYTUxcbiAgICAgICAgLy8gZGVjbGFyYXRpb24gbmFtZS92YWx1ZSBwYWlycy5cbiAgICAgICAgaWYgKGMgPT09IFFVRVNUSU9OKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU19YTUxfREVDTF9FTkRJTkc7XG4gICAgICAgICAgICB0aGlzLmZhaWwoXCJYTUwgZGVjbGFyYXRpb24gaXMgaW5jb21wbGV0ZS5cIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzUyhjKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNRdW90ZShjKSkge1xuICAgICAgICAgICAgdGhpcy5mYWlsKFwidmFsdWUgbXVzdCBiZSBxdW90ZWQuXCIpO1xuICAgICAgICAgICAgdGhpcy5xID0gU1BBQ0U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnEgPSBjO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhdGUgPSBTX1hNTF9ERUNMX1ZBTFVFO1xuICAgIH1cbiAgICBzWE1MRGVjbFZhbHVlKCkge1xuICAgICAgICBjb25zdCBjID0gdGhpcy5jYXB0dXJlVG8oW3RoaXMucSwgUVVFU1RJT05dKTtcbiAgICAgICAgLy8gVGhlIHF1ZXN0aW9uIG1hcmsgY2hhcmFjdGVyIGlzIG5vdCB2YWxpZCBpbnNpZGUgYW55IG9mIHRoZSBYTUxcbiAgICAgICAgLy8gZGVjbGFyYXRpb24gbmFtZS92YWx1ZSBwYWlycy5cbiAgICAgICAgaWYgKGMgPT09IFFVRVNUSU9OKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU19YTUxfREVDTF9FTkRJTkc7XG4gICAgICAgICAgICB0aGlzLnRleHQgPSBcIlwiO1xuICAgICAgICAgICAgdGhpcy5mYWlsKFwiWE1MIGRlY2xhcmF0aW9uIGlzIGluY29tcGxldGUuXCIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjID09PSBFT0MpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMudGV4dDtcbiAgICAgICAgdGhpcy50ZXh0ID0gXCJcIjtcbiAgICAgICAgc3dpdGNoICh0aGlzLm5hbWUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJ2ZXJzaW9uXCI6IHtcbiAgICAgICAgICAgICAgICB0aGlzLnhtbERlY2xFeHBlY3RzID0gW1wiZW5jb2RpbmdcIiwgXCJzdGFuZGFsb25lXCJdO1xuICAgICAgICAgICAgICAgIGNvbnN0IHZlcnNpb24gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLnhtbERlY2wudmVyc2lvbiA9IHZlcnNpb247XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBpcyB0aGUgdGVzdCBzcGVjaWZpZWQgYnkgWE1MIDEuMCBidXQgaXQgaXMgZmluZSBmb3IgWE1MIDEuMS5cbiAgICAgICAgICAgICAgICBpZiAoIS9eMVxcLlswLTldKyQvLnRlc3QodmVyc2lvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mYWlsKFwidmVyc2lvbiBudW1iZXIgbXVzdCBtYXRjaCAvXjFcXFxcLlswLTldKyQvLlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gV2hlbiBmb3JjZVhNTFZlcnNpb24gaXMgc2V0LCB0aGUgWE1MIGRlY2xhcmF0aW9uIGlzIGlnbm9yZWQuXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIXRoaXMub3B0LmZvcmNlWE1MVmVyc2lvbikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFhNTFZlcnNpb24odmVyc2lvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcImVuY29kaW5nXCI6XG4gICAgICAgICAgICAgICAgaWYgKCEvXltBLVphLXpdW0EtWmEtejAtOS5fLV0qJC8udGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mYWlsKFwiZW5jb2RpbmcgdmFsdWUgbXVzdCBtYXRjaCBcXFxuL15bQS1aYS16MC05XVtBLVphLXowLTkuXy1dKiQvLlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy54bWxEZWNsRXhwZWN0cyA9IFtcInN0YW5kYWxvbmVcIl07XG4gICAgICAgICAgICAgICAgdGhpcy54bWxEZWNsLmVuY29kaW5nID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwic3RhbmRhbG9uZVwiOlxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gXCJ5ZXNcIiAmJiB2YWx1ZSAhPT0gXCJub1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmFpbChcInN0YW5kYWxvbmUgdmFsdWUgbXVzdCBtYXRjaCBcXFwieWVzXFxcIiBvciBcXFwibm9cXFwiLlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy54bWxEZWNsRXhwZWN0cyA9IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMueG1sRGVjbC5zdGFuZGFsb25lID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgLy8gV2UgZG9uJ3QgbmVlZCB0byByYWlzZSBhbiBlcnJvciBoZXJlIHNpbmNlIHdlJ3ZlIGFscmVhZHkgcmFpc2VkIG9uZVxuICAgICAgICAgICAgLy8gd2hlbiBjaGVja2luZyB3aGF0IG5hbWUgd2FzIGV4cGVjdGVkLlxuICAgICAgICB9XG4gICAgICAgIHRoaXMubmFtZSA9IFwiXCI7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBTX1hNTF9ERUNMX1NFUEFSQVRPUjtcbiAgICB9XG4gICAgc1hNTERlY2xTZXBhcmF0b3IoKSB7XG4gICAgICAgIGNvbnN0IGMgPSB0aGlzLmdldENvZGVOb3JtKCk7XG4gICAgICAgIC8vIFRoZSBxdWVzdGlvbiBtYXJrIGNoYXJhY3RlciBpcyBub3QgdmFsaWQgaW5zaWRlIGFueSBvZiB0aGUgWE1MXG4gICAgICAgIC8vIGRlY2xhcmF0aW9uIG5hbWUvdmFsdWUgcGFpcnMuXG4gICAgICAgIGlmIChjID09PSBRVUVTVElPTikge1xuICAgICAgICAgICAgLy8gSXQgaXMgdmFsaWQgdG8gZ28gdG8gU19YTUxfREVDTF9FTkRJTkcgZnJvbSB0aGlzIHN0YXRlLlxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFNfWE1MX0RFQ0xfRU5ESU5HO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNTKGMpKSB7XG4gICAgICAgICAgICB0aGlzLmZhaWwoXCJ3aGl0ZXNwYWNlIHJlcXVpcmVkLlwiKTtcbiAgICAgICAgICAgIHRoaXMudW5nZXQoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXRlID0gU19YTUxfREVDTF9OQU1FX1NUQVJUO1xuICAgIH1cbiAgICBzWE1MRGVjbEVuZGluZygpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBjID0gdGhpcy5nZXRDb2RlTm9ybSgpO1xuICAgICAgICBpZiAoYyA9PT0gR1JFQVRFUikge1xuICAgICAgICAgICAgaWYgKHRoaXMucGlUYXJnZXQgIT09IFwieG1sXCIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZhaWwoXCJwcm9jZXNzaW5nIGluc3RydWN0aW9ucyBhcmUgbm90IGFsbG93ZWQgYmVmb3JlIHJvb3QuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5uYW1lICE9PSBcInZlcnNpb25cIiAmJlxuICAgICAgICAgICAgICAgIHRoaXMueG1sRGVjbEV4cGVjdHMuaW5jbHVkZXMoXCJ2ZXJzaW9uXCIpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mYWlsKFwiWE1MIGRlY2xhcmF0aW9uIG11c3QgY29udGFpbiBhIHZlcnNpb24uXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKF9hID0gdGhpcy54bWxkZWNsSGFuZGxlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwodGhpcywgdGhpcy54bWxEZWNsKTtcbiAgICAgICAgICAgIHRoaXMubmFtZSA9IFwiXCI7XG4gICAgICAgICAgICB0aGlzLnBpVGFyZ2V0ID0gdGhpcy50ZXh0ID0gXCJcIjtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTX1RFWFQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBXZSBnb3QgaGVyZSBiZWNhdXNlIHRoZSBwcmV2aW91cyBjaGFyYWN0ZXIgd2FzIGEgPywgYnV0IHRoZSBxdWVzdGlvblxuICAgICAgICAgICAgLy8gbWFyayBjaGFyYWN0ZXIgaXMgbm90IHZhbGlkIGluc2lkZSBhbnkgb2YgdGhlIFhNTCBkZWNsYXJhdGlvblxuICAgICAgICAgICAgLy8gbmFtZS92YWx1ZSBwYWlycy5cbiAgICAgICAgICAgIHRoaXMuZmFpbChcIlRoZSBjaGFyYWN0ZXIgPyBpcyBkaXNhbGxvd2VkIGFueXdoZXJlIGluIFhNTCBkZWNsYXJhdGlvbnMuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMueG1sRGVjbFBvc3NpYmxlID0gZmFsc2U7XG4gICAgfVxuICAgIHNPcGVuVGFnKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IGMgPSB0aGlzLmNhcHR1cmVOYW1lQ2hhcnMoKTtcbiAgICAgICAgaWYgKGMgPT09IEVPQykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRhZyA9IHRoaXMudGFnID0ge1xuICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICAgICAgYXR0cmlidXRlczogT2JqZWN0LmNyZWF0ZShudWxsKSxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5uYW1lID0gXCJcIjtcbiAgICAgICAgaWYgKHRoaXMueG1sbnNPcHQpIHtcbiAgICAgICAgICAgIHRoaXMudG9wTlMgPSB0YWcubnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIChfYSA9IHRoaXMub3BlblRhZ1N0YXJ0SGFuZGxlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwodGhpcywgdGFnKTtcbiAgICAgICAgdGhpcy5zYXdSb290ID0gdHJ1ZTtcbiAgICAgICAgaWYgKCF0aGlzLmZyYWdtZW50T3B0ICYmIHRoaXMuY2xvc2VkUm9vdCkge1xuICAgICAgICAgICAgdGhpcy5mYWlsKFwiZG9jdW1lbnRzIG1heSBjb250YWluIG9ubHkgb25lIHJvb3QuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAoYykge1xuICAgICAgICAgICAgY2FzZSBHUkVBVEVSOlxuICAgICAgICAgICAgICAgIHRoaXMub3BlblRhZygpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBGT1JXQVJEX1NMQVNIOlxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTX09QRU5fVEFHX1NMQVNIO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBpZiAoIWlzUyhjKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZhaWwoXCJkaXNhbGxvd2VkIGNoYXJhY3RlciBpbiB0YWcgbmFtZS5cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTX0FUVFJJQjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzT3BlblRhZ1NsYXNoKCkge1xuICAgICAgICBpZiAodGhpcy5nZXRDb2RlKCkgPT09IEdSRUFURVIpIHtcbiAgICAgICAgICAgIHRoaXMub3BlblNlbGZDbG9zaW5nVGFnKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmZhaWwoXCJmb3J3YXJkLXNsYXNoIGluIG9wZW5pbmcgdGFnIG5vdCBmb2xsb3dlZCBieSA+LlwiKTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTX0FUVFJJQjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzQXR0cmliKCkge1xuICAgICAgICBjb25zdCBjID0gdGhpcy5za2lwU3BhY2VzKCk7XG4gICAgICAgIGlmIChjID09PSBFT0MpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNOYW1lU3RhcnRDaGFyKGMpKSB7XG4gICAgICAgICAgICB0aGlzLnVuZ2V0KCk7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU19BVFRSSUJfTkFNRTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjID09PSBHUkVBVEVSKSB7XG4gICAgICAgICAgICB0aGlzLm9wZW5UYWcoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjID09PSBGT1JXQVJEX1NMQVNIKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU19PUEVOX1RBR19TTEFTSDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZmFpbChcImRpc2FsbG93ZWQgY2hhcmFjdGVyIGluIGF0dHJpYnV0ZSBuYW1lLlwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzQXR0cmliTmFtZSgpIHtcbiAgICAgICAgY29uc3QgYyA9IHRoaXMuY2FwdHVyZU5hbWVDaGFycygpO1xuICAgICAgICBpZiAoYyA9PT0gRVFVQUwpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTX0FUVFJJQl9WQUxVRTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc1MoYykpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTX0FUVFJJQl9OQU1FX1NBV19XSElURTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjID09PSBHUkVBVEVSKSB7XG4gICAgICAgICAgICB0aGlzLmZhaWwoXCJhdHRyaWJ1dGUgd2l0aG91dCB2YWx1ZS5cIik7XG4gICAgICAgICAgICB0aGlzLnB1c2hBdHRyaWIodGhpcy5uYW1lLCB0aGlzLm5hbWUpO1xuICAgICAgICAgICAgdGhpcy5uYW1lID0gdGhpcy50ZXh0ID0gXCJcIjtcbiAgICAgICAgICAgIHRoaXMub3BlblRhZygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGMgIT09IEVPQykge1xuICAgICAgICAgICAgdGhpcy5mYWlsKFwiZGlzYWxsb3dlZCBjaGFyYWN0ZXIgaW4gYXR0cmlidXRlIG5hbWUuXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNBdHRyaWJOYW1lU2F3V2hpdGUoKSB7XG4gICAgICAgIGNvbnN0IGMgPSB0aGlzLnNraXBTcGFjZXMoKTtcbiAgICAgICAgc3dpdGNoIChjKSB7XG4gICAgICAgICAgICBjYXNlIEVPQzpcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjYXNlIEVRVUFMOlxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTX0FUVFJJQl9WQUxVRTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhpcy5mYWlsKFwiYXR0cmlidXRlIHdpdGhvdXQgdmFsdWUuXCIpO1xuICAgICAgICAgICAgICAgIC8vIFNob3VsZCB3ZSBkbyB0aGlzPz8/XG4gICAgICAgICAgICAgICAgLy8gdGhpcy50YWcuYXR0cmlidXRlc1t0aGlzLm5hbWVdID0gXCJcIjtcbiAgICAgICAgICAgICAgICB0aGlzLnRleHQgPSBcIlwiO1xuICAgICAgICAgICAgICAgIHRoaXMubmFtZSA9IFwiXCI7XG4gICAgICAgICAgICAgICAgaWYgKGMgPT09IEdSRUFURVIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vcGVuVGFnKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzTmFtZVN0YXJ0Q2hhcihjKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnVuZ2V0KCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTX0FUVFJJQl9OQU1FO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mYWlsKFwiZGlzYWxsb3dlZCBjaGFyYWN0ZXIgaW4gYXR0cmlidXRlIG5hbWUuXCIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gU19BVFRSSUI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHNBdHRyaWJWYWx1ZSgpIHtcbiAgICAgICAgY29uc3QgYyA9IHRoaXMuZ2V0Q29kZU5vcm0oKTtcbiAgICAgICAgaWYgKGlzUXVvdGUoYykpIHtcbiAgICAgICAgICAgIHRoaXMucSA9IGM7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU19BVFRSSUJfVkFMVUVfUVVPVEVEO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFpc1MoYykpIHtcbiAgICAgICAgICAgIHRoaXMuZmFpbChcInVucXVvdGVkIGF0dHJpYnV0ZSB2YWx1ZS5cIik7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU19BVFRSSUJfVkFMVUVfVU5RVU9URUQ7XG4gICAgICAgICAgICB0aGlzLnVuZ2V0KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc0F0dHJpYlZhbHVlUXVvdGVkKCkge1xuICAgICAgICAvLyBXZSBkZWxpYmVyYXRlbHkgZG8gbm90IHVzZSBjYXB0dXJlVG8gaGVyZS4gVGhlIHNwZWNpYWxpemVkIGNvZGUgd2UgdXNlXG4gICAgICAgIC8vIGhlcmUgaXMgZmFzdGVyIHRoYW4gdXNpbmcgY2FwdHVyZVRvLlxuICAgICAgICBjb25zdCB7IHEsIGNodW5rIH0gPSB0aGlzO1xuICAgICAgICBsZXQgeyBpOiBzdGFydCB9ID0gdGhpcztcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnN0YW50LWNvbmRpdGlvblxuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgc3dpdGNoICh0aGlzLmdldENvZGUoKSkge1xuICAgICAgICAgICAgICAgIGNhc2UgcTpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wdXNoQXR0cmliKHRoaXMubmFtZSwgdGhpcy50ZXh0ICsgY2h1bmsuc2xpY2Uoc3RhcnQsIHRoaXMucHJldkkpKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5uYW1lID0gdGhpcy50ZXh0ID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5xID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFNfQVRUUklCX1ZBTFVFX0NMT1NFRDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGNhc2UgQU1QOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRleHQgKz0gY2h1bmsuc2xpY2Uoc3RhcnQsIHRoaXMucHJldkkpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gU19FTlRJVFk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW50aXR5UmV0dXJuU3RhdGUgPSBTX0FUVFJJQl9WQUxVRV9RVU9URUQ7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBjYXNlIE5MOlxuICAgICAgICAgICAgICAgIGNhc2UgTkxfTElLRTpcbiAgICAgICAgICAgICAgICBjYXNlIFRBQjpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50ZXh0ICs9IGAke2NodW5rLnNsaWNlKHN0YXJ0LCB0aGlzLnByZXZJKX0gYDtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSB0aGlzLmk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgTEVTUzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50ZXh0ICs9IGNodW5rLnNsaWNlKHN0YXJ0LCB0aGlzLnByZXZJKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mYWlsKFwiZGlzYWxsb3dlZCBjaGFyYWN0ZXIuXCIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgY2FzZSBFT0M6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGV4dCArPSBjaHVuay5zbGljZShzdGFydCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHNBdHRyaWJWYWx1ZUNsb3NlZCgpIHtcbiAgICAgICAgY29uc3QgYyA9IHRoaXMuZ2V0Q29kZU5vcm0oKTtcbiAgICAgICAgaWYgKGlzUyhjKSkge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFNfQVRUUklCO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGMgPT09IEdSRUFURVIpIHtcbiAgICAgICAgICAgIHRoaXMub3BlblRhZygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGMgPT09IEZPUldBUkRfU0xBU0gpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTX09QRU5fVEFHX1NMQVNIO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzTmFtZVN0YXJ0Q2hhcihjKSkge1xuICAgICAgICAgICAgdGhpcy5mYWlsKFwibm8gd2hpdGVzcGFjZSBiZXR3ZWVuIGF0dHJpYnV0ZXMuXCIpO1xuICAgICAgICAgICAgdGhpcy51bmdldCgpO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFNfQVRUUklCX05BTUU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmZhaWwoXCJkaXNhbGxvd2VkIGNoYXJhY3RlciBpbiBhdHRyaWJ1dGUgbmFtZS5cIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc0F0dHJpYlZhbHVlVW5xdW90ZWQoKSB7XG4gICAgICAgIC8vIFdlIGRvbid0IGRvIGFueXRoaW5nIHJlZ2FyZGluZyBFT0wgb3Igc3BhY2UgaGFuZGxpbmcgZm9yIHVucXVvdGVkXG4gICAgICAgIC8vIGF0dHJpYnV0ZXMuIFdlIGFscmVhZHkgaGF2ZSBmYWlsZWQgYnkgdGhlIHRpbWUgd2UgZ2V0IGhlcmUsIGFuZCB0aGVcbiAgICAgICAgLy8gY29udHJhY3QgdGhhdCBzYXhlcyB1cGhvbGRzIHN0YXRlcyB0aGF0IHVwb24gZmFpbHVyZSwgaXQgaXMgbm90IHNhZmUgdG9cbiAgICAgICAgLy8gcmVseSBvbiB0aGUgZGF0YSBwYXNzZWQgdG8gZXZlbnQgaGFuZGxlcnMgKG90aGVyIHRoYW5cbiAgICAgICAgLy8gYGBvbmVycm9yYGApLiBQYXNzaW5nIFwiYmFkXCIgZGF0YSBpcyBub3QgYSBwcm9ibGVtLlxuICAgICAgICBjb25zdCBjID0gdGhpcy5jYXB0dXJlVG8oQVRUUklCX1ZBTFVFX1VOUVVPVEVEX1RFUk1JTkFUT1IpO1xuICAgICAgICBzd2l0Y2ggKGMpIHtcbiAgICAgICAgICAgIGNhc2UgQU1QOlxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTX0VOVElUWTtcbiAgICAgICAgICAgICAgICB0aGlzLmVudGl0eVJldHVyblN0YXRlID0gU19BVFRSSUJfVkFMVUVfVU5RVU9URUQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIExFU1M6XG4gICAgICAgICAgICAgICAgdGhpcy5mYWlsKFwiZGlzYWxsb3dlZCBjaGFyYWN0ZXIuXCIpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBFT0M6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnRleHQuaW5jbHVkZXMoXCJdXT5cIikpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mYWlsKFwidGhlIHN0cmluZyBcXFwiXV0+XFxcIiBpcyBkaXNhbGxvd2VkIGluIGNoYXIgZGF0YS5cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMucHVzaEF0dHJpYih0aGlzLm5hbWUsIHRoaXMudGV4dCk7XG4gICAgICAgICAgICAgICAgdGhpcy5uYW1lID0gdGhpcy50ZXh0ID0gXCJcIjtcbiAgICAgICAgICAgICAgICBpZiAoYyA9PT0gR1JFQVRFUikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9wZW5UYWcoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTX0FUVFJJQjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgc0Nsb3NlVGFnKCkge1xuICAgICAgICBjb25zdCBjID0gdGhpcy5jYXB0dXJlTmFtZUNoYXJzKCk7XG4gICAgICAgIGlmIChjID09PSBHUkVBVEVSKSB7XG4gICAgICAgICAgICB0aGlzLmNsb3NlVGFnKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNTKGMpKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU19DTE9TRV9UQUdfU0FXX1dISVRFO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGMgIT09IEVPQykge1xuICAgICAgICAgICAgdGhpcy5mYWlsKFwiZGlzYWxsb3dlZCBjaGFyYWN0ZXIgaW4gY2xvc2luZyB0YWcuXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNDbG9zZVRhZ1Nhd1doaXRlKCkge1xuICAgICAgICBzd2l0Y2ggKHRoaXMuc2tpcFNwYWNlcygpKSB7XG4gICAgICAgICAgICBjYXNlIEdSRUFURVI6XG4gICAgICAgICAgICAgICAgdGhpcy5jbG9zZVRhZygpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBFT0M6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRoaXMuZmFpbChcImRpc2FsbG93ZWQgY2hhcmFjdGVyIGluIGNsb3NpbmcgdGFnLlwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBFTkQgT0YgU1RBVEUgRU5HSU5FIE1FVEhPRFNcbiAgICBoYW5kbGVUZXh0SW5Sb290KCkge1xuICAgICAgICAvLyBUaGlzIGlzIGVzc2VudGlhbGx5IGEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBjYXB0dXJlVG8gd2hpY2ggaXMgb3B0aW1pemVkXG4gICAgICAgIC8vIGZvciBwZXJmb3JtaW5nIHRoZSBdXT4gY2hlY2suIEEgcHJldmlvdXMgdmVyc2lvbiBvZiB0aGlzIGNvZGUsIGNoZWNrZWRcbiAgICAgICAgLy8gYGB0aGlzLnRleHRgYCBmb3IgdGhlIHByZXNlbmNlIG9mIF1dPi4gSXQgc2ltcGxpZmllZCB0aGUgY29kZSBidXQgd2FzXG4gICAgICAgIC8vIHZlcnkgY29zdGx5IHdoZW4gY2hhcmFjdGVyIGRhdGEgY29udGFpbmVkIGEgbG90IG9mIGVudGl0aWVzIHRvIGJlIHBhcnNlZC5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gU2luY2Ugd2UgYXJlIHVzaW5nIGEgc3BlY2lhbGl6ZWQgbG9vcCwgd2UgYWxzbyBrZWVwIHRyYWNrIG9mIHRoZSBwcmVzZW5jZVxuICAgICAgICAvLyBvZiBdXT4gaW4gdGV4dCBkYXRhLiBUaGUgc2VxdWVuY2UgXV0+IGlzIGZvcmJpZGRlbiB0byBhcHBlYXIgYXMtaXMuXG4gICAgICAgIC8vXG4gICAgICAgIGxldCB7IGk6IHN0YXJ0LCBmb3JiaWRkZW5TdGF0ZSB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgeyBjaHVuaywgdGV4dEhhbmRsZXI6IGhhbmRsZXIgfSA9IHRoaXM7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1sYWJlbHMsIG5vLXJlc3RyaWN0ZWQtc3ludGF4XG4gICAgICAgIHNjYW5Mb29wOiBcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnN0YW50LWNvbmRpdGlvblxuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgc3dpdGNoICh0aGlzLmdldENvZGUoKSkge1xuICAgICAgICAgICAgICAgIGNhc2UgTEVTUzoge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gU19PUEVOX1dBS0E7XG4gICAgICAgICAgICAgICAgICAgIGlmIChoYW5kbGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgdGV4dCB9ID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNsaWNlID0gY2h1bmsuc2xpY2Uoc3RhcnQsIHRoaXMucHJldkkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRleHQubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlcih0ZXh0ICsgc2xpY2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudGV4dCA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChzbGljZS5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVyKHNsaWNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmb3JiaWRkZW5TdGF0ZSA9IEZPUkJJRERFTl9TVEFSVDtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWxhYmVsc1xuICAgICAgICAgICAgICAgICAgICBicmVhayBzY2FuTG9vcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSBBTVA6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTX0VOVElUWTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbnRpdHlSZXR1cm5TdGF0ZSA9IFNfVEVYVDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhhbmRsZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50ZXh0ICs9IGNodW5rLnNsaWNlKHN0YXJ0LCB0aGlzLnByZXZJKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmb3JiaWRkZW5TdGF0ZSA9IEZPUkJJRERFTl9TVEFSVDtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWxhYmVsc1xuICAgICAgICAgICAgICAgICAgICBicmVhayBzY2FuTG9vcDtcbiAgICAgICAgICAgICAgICBjYXNlIENMT1NFX0JSQUNLRVQ6XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoZm9yYmlkZGVuU3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgRk9SQklEREVOX1NUQVJUOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcmJpZGRlblN0YXRlID0gRk9SQklEREVOX0JSQUNLRVQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIEZPUkJJRERFTl9CUkFDS0VUOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcmJpZGRlblN0YXRlID0gRk9SQklEREVOX0JSQUNLRVRfQlJBQ0tFVDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgRk9SQklEREVOX0JSQUNLRVRfQlJBQ0tFVDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW1wb3NzaWJsZSBzdGF0ZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIEdSRUFURVI6XG4gICAgICAgICAgICAgICAgICAgIGlmIChmb3JiaWRkZW5TdGF0ZSA9PT0gRk9SQklEREVOX0JSQUNLRVRfQlJBQ0tFVCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5mYWlsKFwidGhlIHN0cmluZyBcXFwiXV0+XFxcIiBpcyBkaXNhbGxvd2VkIGluIGNoYXIgZGF0YS5cIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZm9yYmlkZGVuU3RhdGUgPSBGT1JCSURERU5fU1RBUlQ7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgTkxfTElLRTpcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhhbmRsZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50ZXh0ICs9IGAke2NodW5rLnNsaWNlKHN0YXJ0LCB0aGlzLnByZXZJKX1cXG5gO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gdGhpcy5pO1xuICAgICAgICAgICAgICAgICAgICBmb3JiaWRkZW5TdGF0ZSA9IEZPUkJJRERFTl9TVEFSVDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBFT0M6XG4gICAgICAgICAgICAgICAgICAgIGlmIChoYW5kbGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudGV4dCArPSBjaHVuay5zbGljZShzdGFydCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWxhYmVsc1xuICAgICAgICAgICAgICAgICAgICBicmVhayBzY2FuTG9vcDtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBmb3JiaWRkZW5TdGF0ZSA9IEZPUkJJRERFTl9TVEFSVDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZvcmJpZGRlblN0YXRlID0gZm9yYmlkZGVuU3RhdGU7XG4gICAgfVxuICAgIGhhbmRsZVRleHRPdXRzaWRlUm9vdCgpIHtcbiAgICAgICAgLy8gVGhpcyBpcyBlc3NlbnRpYWxseSBhIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgY2FwdHVyZVRvIHdoaWNoIGlzIG9wdGltaXplZFxuICAgICAgICAvLyBmb3IgYSBzcGVjaWFsaXplZCB0YXNrLiBXZSBrZWVwIHRyYWNrIG9mIHRoZSBwcmVzZW5jZSBvZiBub24tc3BhY2VcbiAgICAgICAgLy8gY2hhcmFjdGVycyBpbiB0aGUgdGV4dCBzaW5jZSB0aGVzZSBhcmUgZXJyb3JzIHdoZW4gYXBwZWFyaW5nIG91dHNpZGUgdGhlXG4gICAgICAgIC8vIGRvY3VtZW50IHJvb3QgZWxlbWVudC5cbiAgICAgICAgbGV0IHsgaTogc3RhcnQgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHsgY2h1bmssIHRleHRIYW5kbGVyOiBoYW5kbGVyIH0gPSB0aGlzO1xuICAgICAgICBsZXQgbm9uU3BhY2UgPSBmYWxzZTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWxhYmVscywgbm8tcmVzdHJpY3RlZC1zeW50YXhcbiAgICAgICAgb3V0Um9vdExvb3A6IFxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc3RhbnQtY29uZGl0aW9uXG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBjb25zdCBjb2RlID0gdGhpcy5nZXRDb2RlKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKGNvZGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIExFU1M6IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFNfT1BFTl9XQUtBO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaGFuZGxlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHRleHQgfSA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzbGljZSA9IGNodW5rLnNsaWNlKHN0YXJ0LCB0aGlzLnByZXZJKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0ZXh0Lmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZXIodGV4dCArIHNsaWNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRleHQgPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoc2xpY2UubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlcihzbGljZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWxhYmVsc1xuICAgICAgICAgICAgICAgICAgICBicmVhayBvdXRSb290TG9vcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSBBTVA6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTX0VOVElUWTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbnRpdHlSZXR1cm5TdGF0ZSA9IFNfVEVYVDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhhbmRsZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50ZXh0ICs9IGNodW5rLnNsaWNlKHN0YXJ0LCB0aGlzLnByZXZJKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBub25TcGFjZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1sYWJlbHNcbiAgICAgICAgICAgICAgICAgICAgYnJlYWsgb3V0Um9vdExvb3A7XG4gICAgICAgICAgICAgICAgY2FzZSBOTF9MSUtFOlxuICAgICAgICAgICAgICAgICAgICBpZiAoaGFuZGxlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRleHQgKz0gYCR7Y2h1bmsuc2xpY2Uoc3RhcnQsIHRoaXMucHJldkkpfVxcbmA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSB0aGlzLmk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgRU9DOlxuICAgICAgICAgICAgICAgICAgICBpZiAoaGFuZGxlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRleHQgKz0gY2h1bmsuc2xpY2Uoc3RhcnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1sYWJlbHNcbiAgICAgICAgICAgICAgICAgICAgYnJlYWsgb3V0Um9vdExvb3A7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1MoY29kZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vblNwYWNlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghbm9uU3BhY2UpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBXZSB1c2UgdGhlIHJlcG9ydGVkVGV4dEJlZm9yZVJvb3QgYW5kIHJlcG9ydGVkVGV4dEFmdGVyUm9vdCBmbGFnc1xuICAgICAgICAvLyB0byBhdm9pZCByZXBvcnRpbmcgZXJyb3JzIGZvciBldmVyeSBzaW5nbGUgY2hhcmFjdGVyIHRoYXQgaXMgb3V0IG9mXG4gICAgICAgIC8vIHBsYWNlLlxuICAgICAgICBpZiAoIXRoaXMuc2F3Um9vdCAmJiAhdGhpcy5yZXBvcnRlZFRleHRCZWZvcmVSb290KSB7XG4gICAgICAgICAgICB0aGlzLmZhaWwoXCJ0ZXh0IGRhdGEgb3V0c2lkZSBvZiByb290IG5vZGUuXCIpO1xuICAgICAgICAgICAgdGhpcy5yZXBvcnRlZFRleHRCZWZvcmVSb290ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jbG9zZWRSb290ICYmICF0aGlzLnJlcG9ydGVkVGV4dEFmdGVyUm9vdCkge1xuICAgICAgICAgICAgdGhpcy5mYWlsKFwidGV4dCBkYXRhIG91dHNpZGUgb2Ygcm9vdCBub2RlLlwiKTtcbiAgICAgICAgICAgIHRoaXMucmVwb3J0ZWRUZXh0QWZ0ZXJSb290ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwdXNoQXR0cmliTlMobmFtZSwgdmFsdWUpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCB7IHByZWZpeCwgbG9jYWwgfSA9IHRoaXMucW5hbWUobmFtZSk7XG4gICAgICAgIGNvbnN0IGF0dHIgPSB7IG5hbWUsIHByZWZpeCwgbG9jYWwsIHZhbHVlIH07XG4gICAgICAgIHRoaXMuYXR0cmliTGlzdC5wdXNoKGF0dHIpO1xuICAgICAgICAoX2EgPSB0aGlzLmF0dHJpYnV0ZUhhbmRsZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHRoaXMsIGF0dHIpO1xuICAgICAgICBpZiAocHJlZml4ID09PSBcInhtbG5zXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IHRyaW1tZWQgPSB2YWx1ZS50cmltKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50WE1MVmVyc2lvbiA9PT0gXCIxLjBcIiAmJiB0cmltbWVkID09PSBcIlwiKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mYWlsKFwiaW52YWxpZCBhdHRlbXB0IHRvIHVuZGVmaW5lIHByZWZpeCBpbiBYTUwgMS4wXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy50b3BOU1tsb2NhbF0gPSB0cmltbWVkO1xuICAgICAgICAgICAgbnNQYWlyQ2hlY2sodGhpcywgbG9jYWwsIHRyaW1tZWQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5hbWUgPT09IFwieG1sbnNcIikge1xuICAgICAgICAgICAgY29uc3QgdHJpbW1lZCA9IHZhbHVlLnRyaW0oKTtcbiAgICAgICAgICAgIHRoaXMudG9wTlNbXCJcIl0gPSB0cmltbWVkO1xuICAgICAgICAgICAgbnNQYWlyQ2hlY2sodGhpcywgXCJcIiwgdHJpbW1lZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcHVzaEF0dHJpYlBsYWluKG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgYXR0ciA9IHsgbmFtZSwgdmFsdWUgfTtcbiAgICAgICAgdGhpcy5hdHRyaWJMaXN0LnB1c2goYXR0cik7XG4gICAgICAgIChfYSA9IHRoaXMuYXR0cmlidXRlSGFuZGxlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwodGhpcywgYXR0cik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuZCBwYXJzaW5nLiBUaGlzIHBlcmZvcm1zIGZpbmFsIHdlbGwtZm9ybWVkbmVzcyBjaGVja3MgYW5kIHJlc2V0cyB0aGVcbiAgICAgKiBwYXJzZXIgdG8gYSBjbGVhbiBzdGF0ZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHRoaXNcbiAgICAgKi9cbiAgICBlbmQoKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGlmICghdGhpcy5zYXdSb290KSB7XG4gICAgICAgICAgICB0aGlzLmZhaWwoXCJkb2N1bWVudCBtdXN0IGNvbnRhaW4gYSByb290IGVsZW1lbnQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgdGFncyB9ID0gdGhpcztcbiAgICAgICAgd2hpbGUgKHRhZ3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gdGFncy5wb3AoKTtcbiAgICAgICAgICAgIHRoaXMuZmFpbChgdW5jbG9zZWQgdGFnOiAke3RhZy5uYW1lfWApO1xuICAgICAgICB9XG4gICAgICAgIGlmICgodGhpcy5zdGF0ZSAhPT0gU19CRUdJTikgJiYgKHRoaXMuc3RhdGUgIT09IFNfVEVYVCkpIHtcbiAgICAgICAgICAgIHRoaXMuZmFpbChcInVuZXhwZWN0ZWQgZW5kLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IHRleHQgfSA9IHRoaXM7XG4gICAgICAgIGlmICh0ZXh0Lmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgKF9hID0gdGhpcy50ZXh0SGFuZGxlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwodGhpcywgdGV4dCk7XG4gICAgICAgICAgICB0aGlzLnRleHQgPSBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2Nsb3NlZCA9IHRydWU7XG4gICAgICAgIChfYiA9IHRoaXMuZW5kSGFuZGxlcikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuX2luaXQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc29sdmUgYSBuYW1lc3BhY2UgcHJlZml4LlxuICAgICAqXG4gICAgICogQHBhcmFtIHByZWZpeCBUaGUgcHJlZml4IHRvIHJlc29sdmUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgbmFtZXNwYWNlIFVSSSBvciBgYHVuZGVmaW5lZGBgIGlmIHRoZSBwcmVmaXggaXMgbm90IGRlZmluZWQuXG4gICAgICovXG4gICAgcmVzb2x2ZShwcmVmaXgpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgbGV0IHVyaSA9IHRoaXMudG9wTlNbcHJlZml4XTtcbiAgICAgICAgaWYgKHVyaSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdXJpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgdGFncyB9ID0gdGhpcztcbiAgICAgICAgZm9yIChsZXQgaW5kZXggPSB0YWdzLmxlbmd0aCAtIDE7IGluZGV4ID49IDA7IGluZGV4LS0pIHtcbiAgICAgICAgICAgIHVyaSA9IHRhZ3NbaW5kZXhdLm5zW3ByZWZpeF07XG4gICAgICAgICAgICBpZiAodXJpICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdXJpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHVyaSA9IHRoaXMubnNbcHJlZml4XTtcbiAgICAgICAgaWYgKHVyaSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdXJpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoX2IgPSAoX2EgPSB0aGlzLm9wdCkucmVzb2x2ZVByZWZpeCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIHByZWZpeCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBhcnNlIGEgcW5hbWUgaW50byBpdHMgcHJlZml4IGFuZCBsb2NhbCBuYW1lIHBhcnRzLlxuICAgICAqXG4gICAgICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgdG8gcGFyc2VcbiAgICAgKlxuICAgICAqIEByZXR1cm5zXG4gICAgICovXG4gICAgcW5hbWUobmFtZSkge1xuICAgICAgICAvLyBUaGlzIGlzIGZhc3RlciB0aGFuIHVzaW5nIG5hbWUuc3BsaXQoXCI6XCIpLlxuICAgICAgICBjb25zdCBjb2xvbiA9IG5hbWUuaW5kZXhPZihcIjpcIik7XG4gICAgICAgIGlmIChjb2xvbiA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHByZWZpeDogXCJcIiwgbG9jYWw6IG5hbWUgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsb2NhbCA9IG5hbWUuc2xpY2UoY29sb24gKyAxKTtcbiAgICAgICAgY29uc3QgcHJlZml4ID0gbmFtZS5zbGljZSgwLCBjb2xvbik7XG4gICAgICAgIGlmIChwcmVmaXggPT09IFwiXCIgfHwgbG9jYWwgPT09IFwiXCIgfHwgbG9jYWwuaW5jbHVkZXMoXCI6XCIpKSB7XG4gICAgICAgICAgICB0aGlzLmZhaWwoYG1hbGZvcm1lZCBuYW1lOiAke25hbWV9LmApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHByZWZpeCwgbG9jYWwgfTtcbiAgICB9XG4gICAgcHJvY2Vzc0F0dHJpYnNOUygpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCB7IGF0dHJpYkxpc3QgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHRhZyA9IHRoaXMudGFnO1xuICAgICAgICB7XG4gICAgICAgICAgICAvLyBhZGQgbmFtZXNwYWNlIGluZm8gdG8gdGFnXG4gICAgICAgICAgICBjb25zdCB7IHByZWZpeCwgbG9jYWwgfSA9IHRoaXMucW5hbWUodGFnLm5hbWUpO1xuICAgICAgICAgICAgdGFnLnByZWZpeCA9IHByZWZpeDtcbiAgICAgICAgICAgIHRhZy5sb2NhbCA9IGxvY2FsO1xuICAgICAgICAgICAgY29uc3QgdXJpID0gdGFnLnVyaSA9IChfYSA9IHRoaXMucmVzb2x2ZShwcmVmaXgpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBcIlwiO1xuICAgICAgICAgICAgaWYgKHByZWZpeCAhPT0gXCJcIikge1xuICAgICAgICAgICAgICAgIGlmIChwcmVmaXggPT09IFwieG1sbnNcIikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZhaWwoXCJ0YWdzIG1heSBub3QgaGF2ZSBcXFwieG1sbnNcXFwiIGFzIHByZWZpeC5cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh1cmkgPT09IFwiXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mYWlsKGB1bmJvdW5kIG5hbWVzcGFjZSBwcmVmaXg6ICR7SlNPTi5zdHJpbmdpZnkocHJlZml4KX0uYCk7XG4gICAgICAgICAgICAgICAgICAgIHRhZy51cmkgPSBwcmVmaXg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChhdHRyaWJMaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgYXR0cmlidXRlcyB9ID0gdGFnO1xuICAgICAgICBjb25zdCBzZWVuID0gbmV3IFNldCgpO1xuICAgICAgICAvLyBOb3RlOiBkbyBub3QgYXBwbHkgZGVmYXVsdCBucyB0byBhdHRyaWJ1dGVzOlxuICAgICAgICAvLyAgIGh0dHA6Ly93d3cudzMub3JnL1RSL1JFQy14bWwtbmFtZXMvI2RlZmF1bHRpbmdcbiAgICAgICAgZm9yIChjb25zdCBhdHRyIG9mIGF0dHJpYkxpc3QpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgbmFtZSwgcHJlZml4LCBsb2NhbCB9ID0gYXR0cjtcbiAgICAgICAgICAgIGxldCB1cmk7XG4gICAgICAgICAgICBsZXQgZXFuYW1lO1xuICAgICAgICAgICAgaWYgKHByZWZpeCA9PT0gXCJcIikge1xuICAgICAgICAgICAgICAgIHVyaSA9IG5hbWUgPT09IFwieG1sbnNcIiA/IFhNTE5TX05BTUVTUEFDRSA6IFwiXCI7XG4gICAgICAgICAgICAgICAgZXFuYW1lID0gbmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHVyaSA9IHRoaXMucmVzb2x2ZShwcmVmaXgpO1xuICAgICAgICAgICAgICAgIC8vIGlmIHRoZXJlJ3MgYW55IGF0dHJpYnV0ZXMgd2l0aCBhbiB1bmRlZmluZWQgbmFtZXNwYWNlLFxuICAgICAgICAgICAgICAgIC8vIHRoZW4gZmFpbCBvbiB0aGVtIG5vdy5cbiAgICAgICAgICAgICAgICBpZiAodXJpID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mYWlsKGB1bmJvdW5kIG5hbWVzcGFjZSBwcmVmaXg6ICR7SlNPTi5zdHJpbmdpZnkocHJlZml4KX0uYCk7XG4gICAgICAgICAgICAgICAgICAgIHVyaSA9IHByZWZpeDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZXFuYW1lID0gYHske3VyaX19JHtsb2NhbH1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNlZW4uaGFzKGVxbmFtZSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZhaWwoYGR1cGxpY2F0ZSBhdHRyaWJ1dGU6ICR7ZXFuYW1lfS5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlZW4uYWRkKGVxbmFtZSk7XG4gICAgICAgICAgICBhdHRyLnVyaSA9IHVyaTtcbiAgICAgICAgICAgIGF0dHJpYnV0ZXNbbmFtZV0gPSBhdHRyO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYXR0cmliTGlzdCA9IFtdO1xuICAgIH1cbiAgICBwcm9jZXNzQXR0cmlic1BsYWluKCkge1xuICAgICAgICBjb25zdCB7IGF0dHJpYkxpc3QgfSA9IHRoaXM7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItZGVzdHJ1Y3R1cmluZ1xuICAgICAgICBjb25zdCBhdHRyaWJ1dGVzID0gdGhpcy50YWcuYXR0cmlidXRlcztcbiAgICAgICAgZm9yIChjb25zdCB7IG5hbWUsIHZhbHVlIH0gb2YgYXR0cmliTGlzdCkge1xuICAgICAgICAgICAgaWYgKGF0dHJpYnV0ZXNbbmFtZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZmFpbChgZHVwbGljYXRlIGF0dHJpYnV0ZTogJHtuYW1lfS5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF0dHJpYnV0ZXNbbmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmF0dHJpYkxpc3QgPSBbXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGFuZGxlIGEgY29tcGxldGUgb3BlbiB0YWcuIFRoaXMgcGFyc2VyIGNvZGUgY2FsbHMgdGhpcyBvbmNlIGl0IGhhcyBzZWVuXG4gICAgICogdGhlIHdob2xlIHRhZy4gVGhpcyBtZXRob2QgY2hlY2tzIGZvciB3ZWxsLWZvcm1lbmVzcyBhbmQgdGhlbiBlbWl0c1xuICAgICAqIGBgb25vcGVudGFnYGAuXG4gICAgICovXG4gICAgb3BlblRhZygpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB0aGlzLnByb2Nlc3NBdHRyaWJzKCk7XG4gICAgICAgIGNvbnN0IHsgdGFncyB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgdGFnID0gdGhpcy50YWc7XG4gICAgICAgIHRhZy5pc1NlbGZDbG9zaW5nID0gZmFsc2U7XG4gICAgICAgIC8vIFRoZXJlIGNhbm5vdCBiZSBhbnkgcGVuZGluZyB0ZXh0IGhlcmUgZHVlIHRvIHRoZSBvbm9wZW50YWdzdGFydCB0aGF0IHdhc1xuICAgICAgICAvLyBuZWNlc3NhcmlseSBlbWl0dGVkIGJlZm9yZSB3ZSBnZXQgaGVyZS4gU28gd2UgZG8gbm90IGNoZWNrIHRleHQuXG4gICAgICAgIChfYSA9IHRoaXMub3BlblRhZ0hhbmRsZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHRoaXMsIHRhZyk7XG4gICAgICAgIHRhZ3MucHVzaCh0YWcpO1xuICAgICAgICB0aGlzLnN0YXRlID0gU19URVhUO1xuICAgICAgICB0aGlzLm5hbWUgPSBcIlwiO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIYW5kbGUgYSBjb21wbGV0ZSBzZWxmLWNsb3NpbmcgdGFnLiBUaGlzIHBhcnNlciBjb2RlIGNhbGxzIHRoaXMgb25jZSBpdCBoYXNcbiAgICAgKiBzZWVuIHRoZSB3aG9sZSB0YWcuIFRoaXMgbWV0aG9kIGNoZWNrcyBmb3Igd2VsbC1mb3JtZW5lc3MgYW5kIHRoZW4gZW1pdHNcbiAgICAgKiBgYG9ub3BlbnRhZ2BgIGFuZCBgYG9uY2xvc2V0YWdgYC5cbiAgICAgKi9cbiAgICBvcGVuU2VsZkNsb3NpbmdUYWcoKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICB0aGlzLnByb2Nlc3NBdHRyaWJzKCk7XG4gICAgICAgIGNvbnN0IHsgdGFncyB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgdGFnID0gdGhpcy50YWc7XG4gICAgICAgIHRhZy5pc1NlbGZDbG9zaW5nID0gdHJ1ZTtcbiAgICAgICAgLy8gVGhlcmUgY2Fubm90IGJlIGFueSBwZW5kaW5nIHRleHQgaGVyZSBkdWUgdG8gdGhlIG9ub3BlbnRhZ3N0YXJ0IHRoYXQgd2FzXG4gICAgICAgIC8vIG5lY2Vzc2FyaWx5IGVtaXR0ZWQgYmVmb3JlIHdlIGdldCBoZXJlLiBTbyB3ZSBkbyBub3QgY2hlY2sgdGV4dC5cbiAgICAgICAgKF9hID0gdGhpcy5vcGVuVGFnSGFuZGxlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwodGhpcywgdGFnKTtcbiAgICAgICAgKF9iID0gdGhpcy5jbG9zZVRhZ0hhbmRsZXIpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKHRoaXMsIHRhZyk7XG4gICAgICAgIGNvbnN0IHRvcCA9IHRoaXMudGFnID0gKF9jID0gdGFnc1t0YWdzLmxlbmd0aCAtIDFdKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBudWxsO1xuICAgICAgICBpZiAodG9wID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmNsb3NlZFJvb3QgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhdGUgPSBTX1RFWFQ7XG4gICAgICAgIHRoaXMubmFtZSA9IFwiXCI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhhbmRsZSBhIGNvbXBsZXRlIGNsb3NlIHRhZy4gVGhpcyBwYXJzZXIgY29kZSBjYWxscyB0aGlzIG9uY2UgaXQgaGFzIHNlZW5cbiAgICAgKiB0aGUgd2hvbGUgdGFnLiBUaGlzIG1ldGhvZCBjaGVja3MgZm9yIHdlbGwtZm9ybWVuZXNzIGFuZCB0aGVuIGVtaXRzXG4gICAgICogYGBvbmNsb3NldGFnYGAuXG4gICAgICovXG4gICAgY2xvc2VUYWcoKSB7XG4gICAgICAgIGNvbnN0IHsgdGFncywgbmFtZSB9ID0gdGhpcztcbiAgICAgICAgLy8gT3VyIHN0YXRlIGFmdGVyIHRoaXMgd2lsbCBiZSBTX1RFWFQsIG5vIG1hdHRlciB3aGF0LCBhbmQgd2UgY2FuIGNsZWFyXG4gICAgICAgIC8vIHRhZ05hbWUgbm93LlxuICAgICAgICB0aGlzLnN0YXRlID0gU19URVhUO1xuICAgICAgICB0aGlzLm5hbWUgPSBcIlwiO1xuICAgICAgICBpZiAobmFtZSA9PT0gXCJcIikge1xuICAgICAgICAgICAgdGhpcy5mYWlsKFwid2VpcmQgZW1wdHkgY2xvc2UgdGFnLlwiKTtcbiAgICAgICAgICAgIHRoaXMudGV4dCArPSBcIjwvPlwiO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGhhbmRsZXIgPSB0aGlzLmNsb3NlVGFnSGFuZGxlcjtcbiAgICAgICAgbGV0IGwgPSB0YWdzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGwtLSA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHRoaXMudGFnID0gdGFncy5wb3AoKTtcbiAgICAgICAgICAgIHRoaXMudG9wTlMgPSB0YWcubnM7XG4gICAgICAgICAgICBoYW5kbGVyID09PSBudWxsIHx8IGhhbmRsZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGhhbmRsZXIodGFnKTtcbiAgICAgICAgICAgIGlmICh0YWcubmFtZSA9PT0gbmFtZSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5mYWlsKFwidW5leHBlY3RlZCBjbG9zZSB0YWcuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmNsb3NlZFJvb3QgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGwgPCAwKSB7XG4gICAgICAgICAgICB0aGlzLmZhaWwoYHVubWF0Y2hlZCBjbG9zaW5nIHRhZzogJHtuYW1lfS5gKTtcbiAgICAgICAgICAgIHRoaXMudGV4dCArPSBgPC8ke25hbWV9PmA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVzb2x2ZXMgYW4gZW50aXR5LiBNYWtlcyBhbnkgbmVjZXNzYXJ5IHdlbGwtZm9ybWVkbmVzcyBjaGVja3MuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZW50aXR5IFRoZSBlbnRpdHkgdG8gcmVzb2x2ZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBwYXJzZWQgZW50aXR5LlxuICAgICAqL1xuICAgIHBhcnNlRW50aXR5KGVudGl0eSkge1xuICAgICAgICAvLyBzdGFydHNXaXRoIHdvdWxkIGJlIHNpZ25pZmljYW50bHkgc2xvd2VyIGZvciB0aGlzIHRlc3QuXG4gICAgICAgIGlmIChlbnRpdHlbMF0gIT09IFwiI1wiKSB7XG4gICAgICAgICAgICBjb25zdCBkZWZpbmVkID0gdGhpcy5FTlRJVElFU1tlbnRpdHldO1xuICAgICAgICAgICAgaWYgKGRlZmluZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5mYWlsKHRoaXMuaXNOYW1lKGVudGl0eSkgPyBcInVuZGVmaW5lZCBlbnRpdHkuXCIgOlxuICAgICAgICAgICAgICAgIFwiZGlzYWxsb3dlZCBjaGFyYWN0ZXIgaW4gZW50aXR5IG5hbWUuXCIpO1xuICAgICAgICAgICAgcmV0dXJuIGAmJHtlbnRpdHl9O2A7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG51bSA9IE5hTjtcbiAgICAgICAgaWYgKGVudGl0eVsxXSA9PT0gXCJ4XCIgJiYgL14jeFswLTlhLWZdKyQvaS50ZXN0KGVudGl0eSkpIHtcbiAgICAgICAgICAgIG51bSA9IHBhcnNlSW50KGVudGl0eS5zbGljZSgyKSwgMTYpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKC9eI1swLTldKyQvLnRlc3QoZW50aXR5KSkge1xuICAgICAgICAgICAgbnVtID0gcGFyc2VJbnQoZW50aXR5LnNsaWNlKDEpLCAxMCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhlIGNoYXJhY3RlciByZWZlcmVuY2UgaXMgcmVxdWlyZWQgdG8gbWF0Y2ggdGhlIENIQVIgcHJvZHVjdGlvbi5cbiAgICAgICAgaWYgKCF0aGlzLmlzQ2hhcihudW0pKSB7XG4gICAgICAgICAgICB0aGlzLmZhaWwoXCJtYWxmb3JtZWQgY2hhcmFjdGVyIGVudGl0eS5cIik7XG4gICAgICAgICAgICByZXR1cm4gYCYke2VudGl0eX07YDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21Db2RlUG9pbnQobnVtKTtcbiAgICB9XG59XG5leHBvcnRzLlNheGVzUGFyc2VyID0gU2F4ZXNQYXJzZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zYXhlcy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/saxes@6.0.0/node_modules/saxes/saxes.js\n");

/***/ })

};
;